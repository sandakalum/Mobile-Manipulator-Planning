/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2020-11-05 14:29:51.021084
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54;
x0=IKsin(j[0]);
x1=IKcos(j[0]);
x2=IKcos(j[2]);
x3=IKcos(j[1]);
x4=IKsin(j[2]);
x5=IKsin(j[4]);
x6=IKcos(j[3]);
x7=IKsin(j[1]);
x8=IKsin(j[3]);
x9=IKcos(j[4]);
x10=IKcos(j[6]);
x11=IKsin(j[6]);
x12=IKsin(j[5]);
x13=IKcos(j[5]);
x14=((1.0)*x6);
x15=((0.4)*x6);
x16=((1.0)*x8);
x17=((0.00043624)*x3);
x18=((0.4)*x3);
x19=((1.0)*x3);
x20=(x0*x4);
x21=(x0*x7);
x22=(x2*x7);
x23=(x4*x7);
x24=(x0*x2);
x25=(x1*x4);
x26=(x1*x7);
x27=((-1.0)*x12);
x28=(x1*x2);
x29=((-1.0)*x13);
x30=(x14*x21);
x31=(x14*x22);
x32=((((-1.0)*x19*x20))+x28);
x33=(x25+((x24*x3)));
x34=((((-1.0)*x20))+((x28*x3)));
x35=((((-1.0)*x24))+(((-1.0)*x19*x25)));
x36=(x34*x8);
x37=((((-1.0)*x16*x22))+(((-1.0)*x14*x3)));
x38=(((x14*x3))+((x16*x22)));
x39=(x12*x37);
x40=(x35*x5);
x41=((((-1.0)*x30))+((x33*x8)));
x42=(((x34*x6))+((x26*x8)));
x43=(((x9*(((((-1.0)*x31))+((x3*x8))))))+((x23*x5)));
x44=(x36+(((-1.0)*x26*x6)));
x45=(((x5*(((((-1.0)*x16*x3))+x31))))+((x23*x9)));
x46=(x13*x43);
x47=(x42*x9);
x48=(x12*x44);
x49=(((x32*x5))+((x9*((((x21*x8))+((x33*x6)))))));
x50=(((x32*x9))+((x5*(((((-1.0)*x14*x33))+(((-1.0)*x16*x21)))))));
x51=(x47+x40);
x52=(x13*x49);
x53=(x13*x51);
x54=(((x5*(((((1.0)*x14*x34))+(((1.0)*x16*x26))))))+(((-1.0)*x35*x9)));
eerot[0]=(((x11*x50))+((x10*((x52+((x12*x41)))))));
eerot[1]=(((x10*x50))+((x11*((((x27*x41))+((x29*x49)))))));
eerot[2]=(((x13*(((((-1.0)*x16*x33))+x30))))+((x12*x49)));
eetrans[0]=((0.365)+(((-0.00043624)*x0))+((x8*(((((-1.0)*x18*x24))+(((-0.4)*x25))))))+((x17*x24))+(((0.00043624)*x25))+(((0.42)*x21))+((x15*x21)));
eerot[3]=(((x11*x54))+((x10*((((x27*x44))+((x29*x51)))))));
eerot[4]=(((x11*((x48+x53))))+((x10*x54)));
eerot[5]=(((x12*(((((-1.0)*x40))+(((-1.0)*x47))))))+((x13*(((((-1.0)*x14*x26))+x36)))));
eetrans[1]=((-0.18)+(((-1.0)*x15*x26))+((x8*((((x18*x28))+(((-0.4)*x20))))))+(((-1.0)*x17*x28))+(((0.00043624)*x20))+(((-0.42)*x26))+(((0.00043624)*x1)));
eerot[6]=(((x10*((x39+x46))))+((x11*x45)));
eerot[7]=(((x10*x45))+((x11*(((((-1.0)*x39))+(((-1.0)*x46)))))));
eerot[8]=(((x12*x43))+((x13*x38)));
eetrans[2]=((1.02)+(((-0.00043624)*x22))+(((0.4)*x22*x8))+(((0.42)*x3))+((x15*x3)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r10);
new_r01=((-1.0)*r11);
new_r02=((-1.0)*r12);
new_px=((-0.18)+(((-1.0)*py)));
new_r10=r00;
new_r11=r01;
new_r12=r02;
new_py=((-0.365)+px);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=((-1.02)+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x55=((1.0)*px);
IkReal x56=((1.0)*pz);
IkReal x57=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x57))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x56)));
rxp0_2=((((-1.0)*r10*x55))+((py*r00)));
rxp1_0=((((-1.0)*r21*x57))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x56)));
rxp1_2=((((-1.0)*r11*x55))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x57)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x56)));
rxp2_2=((((-1.0)*r12*x55))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x58=((0.00087248)*px);
IkReal x59=((1.0)*pp);
IkReal x60=((((0.00043624)*sj2))+(((-1.0)*py)));
IkReal x61=(x59+x58);
IkReal x62=((0.6724)+(((-1.0)*x61)));
IkReal x63=((0.0004)+(((-1.0)*x61)));
IkReal x64=((0.6724)+x58+(((-1.0)*x59)));
IkReal x65=((0.0004)+x58+(((-1.0)*x59)));
IkReal gconst0=x60;
IkReal gconst1=x60;
IkReal gconst2=x62;
IkReal gconst3=x63;
IkReal gconst4=x60;
IkReal gconst5=x60;
IkReal gconst6=x62;
IkReal gconst7=x63;
IkReal gconst8=x64;
IkReal gconst9=x65;
IkReal gconst10=x64;
IkReal gconst11=x65;
IkReal x66=sj2*sj2;
IkReal x67=py*py;
IkReal x68=px*px;
IkReal x69=(gconst10*gconst5);
IkReal x70=((9.74363328512e-7)*gconst4);
IkReal x71=(gconst6*gconst8);
IkReal x72=((0.0011167744)*py);
IkReal x73=(gconst11*gconst4);
IkReal x74=((1.903053376e-7)*gconst8);
IkReal x75=(gconst4*gconst7);
IkReal x76=(gconst3*py);
IkReal x77=(gconst1*gconst8);
IkReal x78=((0.00087248)*sj2);
IkReal x79=((4.0)*px);
IkReal x80=(gconst3*gconst6);
IkReal x81=(gconst11*gconst8);
IkReal x82=(gconst1*py);
IkReal x83=(gconst10*sj2);
IkReal x84=((0.0022335488)*px);
IkReal x85=((0.00174496)*gconst0);
IkReal x86=(px*py);
IkReal x87=(gconst2*gconst5);
IkReal x88=(gconst1*gconst6);
IkReal x89=((2.0)*px);
IkReal x90=(gconst9*py);
IkReal x91=(px*sj2);
IkReal x92=((1.0)*py);
IkReal x93=(gconst7*gconst9);
IkReal x94=(gconst2*gconst6);
IkReal x95=(gconst0*gconst11);
IkReal x96=((0.0005583872)*sj2);
IkReal x97=(gconst4*gconst9);
IkReal x98=((0.00174496)*gconst4);
IkReal x99=(gconst5*py);
IkReal x100=(gconst10*gconst8);
IkReal x101=(gconst1*gconst2);
IkReal x102=((7.612213504e-7)*py);
IkReal x103=(gconst2*py);
IkReal x104=(gconst6*gconst9);
IkReal x105=(py*sj2);
IkReal x106=(gconst8*sj2);
IkReal x107=(gconst11*gconst9);
IkReal x108=(gconst10*gconst3);
IkReal x109=((0.00174496)*gconst5);
IkReal x110=(gconst0*gconst6);
IkReal x111=((0.00043624)*sj2);
IkReal x112=(gconst10*gconst2);
IkReal x113=(gconst1*gconst5);
IkReal x114=((0.0022335488)*py);
IkReal x115=((4.87181664256e-7)*gconst4);
IkReal x116=((1.0)*gconst0);
IkReal x117=(gconst0*gconst5);
IkReal x118=(gconst3*gconst4);
IkReal x119=((0.00174496)*gconst1);
IkReal x120=((0.0011167744)*sj2);
IkReal x121=((7.612213504e-7)*sj2);
IkReal x122=(gconst9*sj2);
IkReal x123=(gconst2*gconst7);
IkReal x124=(gconst10*gconst9);
IkReal x125=((2.12528129215037e-10)*sj2);
IkReal x126=((0.00348992)*gconst4);
IkReal x127=(gconst11*gconst2);
IkReal x128=(gconst0*gconst10);
IkReal x129=(gconst11*gconst3);
IkReal x130=((0.00348992)*px);
IkReal x131=((1.948726657024e-6)*x68);
IkReal x132=(gconst1*x125);
IkReal x133=(py*x115);
IkReal x134=((4.87181664256e-7)*x82);
IkReal x135=(gconst4*x125);
IkReal x136=((9.74363328512e-7)*gconst1*px);
IkReal x137=(px*x70);
IkReal x138=(gconst9*x111);
IkReal x139=((0.00174496)*x91);
IkReal x140=(gconst9*x66);
IkReal x141=(gconst10*x66);
IkReal x142=(py*x66);
IkReal x143=((1.903053376e-7)*x66);
IkReal x144=((1.0)*x67);
IkReal x145=((0.00043624)*x106);
IkReal x146=(gconst7*gconst8*py);
IkReal x147=((4.0)*x68);
IkReal x148=(sj2*x67);
IkReal x149=(gconst6*x66);
IkReal x150=(gconst11*x67);
IkReal x151=(gconst8*x67);
IkReal x152=(gconst3*x66);
IkReal x153=(gconst9*x67);
IkReal x154=(gconst0*gconst3*gconst7);
IkReal x155=((3.0448854016e-6)*x67);
IkReal x156=(gconst10*x67);
IkReal x157=(gconst6*py*x96);
IkReal x158=(x96*x97);
IkReal x159=((2.43590832128e-7)*x149);
IkReal x160=(x76*x96);
IkReal x161=((0.0005583872)*gconst1*x83);
IkReal x162=((2.43590832128e-7)*x152);
IkReal x163=((3.897453314048e-6)*sj2*x86);
IkReal x164=((0.0011167744)*gconst3*x91);
IkReal x165=((0.0011167744)*gconst6*x91);
IkReal x166=(x105*x70);
IkReal x167=((9.74363328512e-7)*sj2*x82);
IkReal x168=((1.948726657024e-6)*x66*x67);
IkReal x169=(x152*x72);
IkReal x170=(x149*x72);
IkReal x171=(x166+x167+x137+x136);
IkReal x172=(x170+x169+x164+x165);
IkReal x173=(x162+x160+x161+x157+x159+x158);
IkReal x174=(x168+x163+x135+x134+x131+x133+x132);
op[0]=(((gconst11*x66*x74))+(((2.43590832128e-7)*x140))+(((2.43590832128e-7)*x141))+(((-4.25056258430075e-10)*x105))+(((-1.0)*py*x100*x78))+(((-4.87181664256e-7)*x67))+(((-9.27132710887679e-14)*x66))+(((0.0005583872)*py*x83))+((x67*x81))+((x90*x96))+((py*x78*x81))+(((-1.0)*x107*x143))+(((-1.0)*x107*x144))+(((-1.0)*gconst11*x78*x90))+(((-0.639999809694662)*x124*x66))+(((-1.0)*x141*x74))+((x124*x67))+(((-1.0)*x100*x144))+((gconst10*x78*x90)));
op[1]=((((-1.0)*py*x100*x79))+(((0.00174496)*gconst9*px*x83))+(((0.0011167744)*px*x83))+(((-8.5011251686015e-10)*x91))+(((0.0011167744)*gconst9*x91))+(((-1.948726657024e-6)*x148))+(((-1.0)*x107*x139))+((py*x79*x81))+((x140*x72))+((gconst10*x79*x90))+((x139*x81))+((x141*x72))+(((-1.948726657024e-6)*x86))+(((-8.5011251686015e-10)*x142))+(((-0.00174496)*gconst8*px*x83))+(((-1.0)*gconst11*x79*x90)));
op[2]=((((-1.0)*gconst10*x103*x78))+((x124*x147))+(((-1.0)*x145*x69))+((x146*x78))+((x138*x69))+(((-1.0)*py*x71*x78))+((x104*x67))+((gconst8*py*x73))+(((-1.0)*x138*x73))+(((-1.0)*x174))+(((4.87181664256e-7)*x140))+(((4.87181664256e-7)*x141))+((x147*x81))+((x122*x72))+(((-1.0)*x144*x93))+((gconst10*x76*x78))+(((-1.0)*x90*x95))+(((-1.0)*gconst8*x69*x92))+(((-1.0)*x143*x71))+(((-0.639999809694662)*x104*x66))+(((-1.0)*x143*x93))+(((-1.0)*x129*x144))+(((-1.0)*x129*x143))+(((-8.5011251686015e-10)*x105))+(((-1.28)*x124*x66))+((x72*x83))+x173+((x108*x67))+((x69*x90))+(((-0.00043624)*x77*x83))+((x127*x143))+(((-9.74363328512e-7)*x67))+(((0.00043624)*gconst0*gconst9*x83))+(((-1.0)*x144*x71))+(((-1.0)*x73*x90))+(((-1.0)*x107*x147))+(((-1.0)*gconst11*x76*x78))+((gconst11*x103*x78))+((x127*x67))+((gconst11*py*x77))+(((-1.0)*x138*x95))+(((-1.0)*gconst10*x77*x92))+(((-1.0)*gconst7*x78*x90))+(((-1.0)*x112*x143))+(((-1.0)*x112*x144))+((x128*x90))+((gconst7*x66*x74))+((gconst6*x78*x90))+(((-1.85426542177536e-13)*x66))+((gconst7*x151))+(((-1.0)*x100*x147))+(((-0.639999809694662)*x108*x66))+((gconst11*x111*x77))+((x145*x73)));
op[3]=(((x127*x139))+(((-1.0)*gconst10*x103*x79))+(((-1.0)*x151*x98))+((gconst9*x69*x89))+((x146*x79))+((gconst6*x79*x90))+((gconst0*x124*x89))+(((-1.0)*py*x71*x79))+((x150*x85))+(((-3.897453314048e-6)*x148))+(((-1.0)*gconst9*x73*x89))+(((-0.00174496)*gconst2*px*x83))+(((-1.0)*x171))+(((-1.0)*x139*x71))+((gconst10*x76*x79))+(((-1.0)*x139*x93))+((gconst8*x73*x89))+(((-1.0)*gconst8*x69*x89))+x172+((gconst4*x121*x90))+((gconst7*gconst8*x139))+((x119*x156))+(((0.00174496)*gconst3*px*x83))+(((-1.0)*x156*x85))+((x104*x139))+(((7.612213504e-7)*x106*x99))+(((-3.897453314048e-6)*x86))+(((-1.0)*gconst11*x76*x79))+((x109*x151))+(((-1.0)*gconst10*x77*x89))+((gconst11*x103*x79))+(((-1.0)*gconst7*x79*x90))+(((-1.7002250337203e-9)*x91))+((x83*x84))+(((-1.0)*gconst9*x89*x95))+((x122*x84))+(((-1.0)*gconst4*x102*x106))+(((-1.0)*gconst11*x121*x82))+(((-1.0)*x129*x139))+(((0.0022335488)*x66*x90))+(((-1.7002250337203e-9)*x142))+(((-1.0)*x119*x150))+(((-1.0)*x109*x153))+(((-1.0)*gconst0*x102*x83))+((gconst11*x77*x89))+(((7.612213504e-7)*x82*x83))+((x114*x141))+(((0.00174496)*x67*x97))+(((-1.0)*gconst5*x121*x90))+((sj2*x102*x95)));
op[4]=((((-1.0)*gconst2*gconst6*(py*py)))+(((0.0011167744)*gconst1*gconst10*sj2))+(((-0.00348992)*gconst5*gconst9*px*py))+(((-0.00043624)*gconst4*gconst7*gconst9*sj2))+(((-1.0)*gconst4*gconst7*gconst9*py))+(((-3.897453314048e-6)*(px*px)))+(((0.00087248)*gconst3*gconst6*py*sj2))+(((-4.25056258430075e-10)*py*sj2))+(((0.00043624)*gconst1*gconst7*gconst8*sj2))+(((-4.0)*gconst10*gconst2*(px*px)))+(((0.00043624)*gconst0*gconst10*gconst3*sj2))+(((-0.00348992)*gconst4*gconst8*px*py))+(((0.00348992)*gconst1*gconst10*px*py))+(((-1.0)*gconst11*gconst3*gconst4*py))+(((1.903053376e-7)*gconst2*gconst7*(sj2*sj2)))+((gconst10*gconst3*gconst5*py))+(((-1.0)*gconst1*gconst10*gconst5*gconst8))+(((0.00348992)*gconst4*gconst9*px*py))+(((-0.00087248)*gconst2*gconst6*py*sj2))+(((-1.0)*gconst0*gconst7*gconst9*py))+(((-4.0)*gconst11*gconst3*(px*px)))+((gconst5*gconst6*gconst9*py))+(((-4.25056258430075e-10)*gconst1*sj2))+(((-0.00043624)*gconst0*gconst7*gconst9*sj2))+(((2.43590832128e-7)*gconst9*(sj2*sj2)))+(((-1.0)*gconst5*gconst6*gconst8*py))+(((0.00043624)*gconst5*gconst6*gconst9*sj2))+(((-4.25056258430075e-10)*gconst4*sj2))+(((-0.639999809694662)*gconst3*gconst6*(sj2*sj2)))+(((-0.00348992)*gconst0*gconst10*px*py))+(((-7.794906628096e-6)*px*py*sj2))+(((-4.87181664256e-7)*(py*py)))+(((-1.0)*gconst10*gconst2*gconst5*py))+((gconst0*gconst6*gconst9*py))+(((4.0)*gconst6*gconst9*(px*px)))+(((-1.0)*gconst1*gconst6*gconst8*py))+((gconst1*gconst11*gconst4*gconst8))+(((-0.00043624)*gconst5*gconst6*gconst8*sj2))+(((-0.00348992)*gconst1*gconst11*px*py))+(((4.0)*gconst7*gconst8*(px*px)))+(((0.00043624)*gconst10*gconst3*gconst5*sj2))+(((0.0011167744)*gconst3*py*sj2))+(((0.0005583872)*gconst3*gconst4*sj2))+(((0.00043624)*gconst0*gconst6*gconst9*sj2))+(((-1.0)*gconst0*gconst11*gconst4*gconst9))+(((4.0)*gconst11*gconst2*(px*px)))+(((-1.0)*gconst1*gconst10*gconst2*py))+(((-9.74363328512e-7)*gconst4*py))+(((-1.0)*gconst0*gconst11*gconst3*py))+(((4.87181664256e-7)*gconst6*(sj2*sj2)))+((gconst11*gconst2*gconst4*py))+(((0.0005583872)*gconst1*gconst6*sj2))+(((0.00087248)*gconst2*gconst7*py*sj2))+((gconst1*gconst11*gconst2*py))+(((-0.00043624)*gconst1*gconst10*gconst2*sj2))+(((-3.897453314048e-6)*(py*py)*(sj2*sj2)))+(((-1.903053376e-7)*gconst3*gconst7*(sj2*sj2)))+((gconst0*gconst10*gconst5*gconst9))+(((-0.00043624)*gconst11*gconst3*gconst4*sj2))+(((-4.87181664256e-7)*gconst1*gconst4))+(((0.00043624)*gconst11*gconst2*gconst4*sj2))+(((4.0)*gconst10*gconst3*(px*px)))+(((-1.28)*gconst10*gconst3*(sj2*sj2)))+(((-0.00087248)*gconst3*gconst7*py*sj2))+(((0.00348992)*gconst5*gconst8*px*py))+(((0.0011167744)*gconst4*gconst9*sj2))+((gconst3*gconst6*(py*py)))+(((0.00043624)*gconst1*gconst11*gconst2*sj2))+(((-1.903053376e-7)*gconst2*gconst6*(sj2*sj2)))+((gconst4*gconst7*gconst8*py))+(((0.0005583872)*gconst9*py*sj2))+(((-9.27132710887679e-14)*(sj2*sj2)))+(((0.0005583872)*gconst10*py*sj2))+(((0.0011167744)*gconst6*py*sj2))+(((-9.74363328512e-7)*gconst1*py))+(((0.00348992)*gconst0*gconst11*px*py))+(((-0.64)*gconst10*gconst9*(sj2*sj2)))+((gconst2*gconst7*(py*py)))+((gconst0*gconst10*gconst3*py))+(((-1.28)*gconst6*gconst9*(sj2*sj2)))+(((-1.0)*gconst3*gconst7*(py*py)))+(((-0.00043624)*gconst10*gconst2*gconst5*sj2))+(((0.00043624)*gconst4*gconst7*gconst8*sj2))+(((4.87181664256e-7)*gconst3*(sj2*sj2)))+((gconst1*gconst7*gconst8*py))+(((-0.00043624)*gconst0*gconst11*gconst3*sj2))+(((2.43590832128e-7)*gconst10*(sj2*sj2)))+(((-4.0)*gconst7*gconst9*(px*px)))+(((-4.0)*gconst6*gconst8*(px*px)))+(((-0.00043624)*gconst1*gconst6*gconst8*sj2)));
op[5]=((((0.0011167744)*gconst9*px*sj2))+(((-0.00174496)*gconst1*gconst4*gconst8*py))+(((0.00174496)*gconst0*gconst11*gconst4*py))+(((7.612213504e-7)*gconst3*gconst4*py*sj2))+(((-4.0)*gconst3*gconst7*px*py))+(((-2.0)*gconst4*gconst7*gconst9*px))+(((2.0)*gconst10*gconst3*gconst5*px))+(((-0.00174496)*gconst0*gconst6*(py*py)))+(((-0.00174496)*gconst3*gconst7*px*sj2))+(((-0.00174496)*gconst0*gconst5*gconst9*py))+(((-2.0)*gconst1*gconst6*gconst8*px))+(((0.00174496)*gconst0*gconst4*gconst9*py))+(((-0.00174496)*gconst1*gconst11*gconst4*py))+(((0.0011167744)*gconst10*py*(sj2*sj2)))+(((-8.5011251686015e-10)*px*sj2))+(((-0.00174496)*gconst2*gconst4*(py*py)))+(((2.0)*gconst0*gconst6*gconst9*px))+(((-7.612213504e-7)*gconst2*gconst4*py*sj2))+(((-0.00174496)*gconst2*gconst6*px*sj2))+(((7.612213504e-7)*gconst0*gconst7*py*sj2))+(((0.00174496)*gconst1*gconst6*(py*py)))+(((-2.0)*gconst11*gconst3*gconst4*px))+(((0.00174496)*gconst2*gconst5*(py*py)))+(((-7.612213504e-7)*gconst1*gconst7*py*sj2))+(((0.0022335488)*gconst6*px*sj2))+(((0.00174496)*gconst1*gconst5*gconst8*py))+(((-2.0)*gconst0*gconst7*gconst9*px))+(((0.00174496)*gconst1*gconst10*gconst5*py))+(((-1.948726657024e-6)*sj2*(py*py)))+(((-1.948726657024e-6)*gconst4*px))+(((2.0)*gconst4*gconst7*gconst8*px))+(((2.0)*gconst0*gconst10*gconst3*px))+(((-7.612213504e-7)*gconst3*gconst5*py*sj2))+(((-0.00174496)*gconst3*gconst5*(py*py)))+(((0.00174496)*gconst3*gconst6*px*sj2))+(((2.0)*gconst5*gconst6*gconst9*px))+(((2.0)*gconst11*gconst2*gconst4*px))+(((-4.0)*gconst2*gconst6*px*py))+(((-1.948726657024e-6)*px*py))+(((-1.948726657024e-6)*gconst1*py*sj2))+(((2.0)*gconst1*gconst7*gconst8*px))+(((0.0011167744)*gconst9*py*(sj2*sj2)))+(((-7.612213504e-7)*gconst0*gconst6*py*sj2))+(((0.00174496)*gconst2*gconst7*px*sj2))+(((-2.0)*gconst1*gconst10*gconst2*px))+(((7.612213504e-7)*gconst2*gconst5*py*sj2))+(((-8.5011251686015e-10)*py*(sj2*sj2)))+(((-0.00174496)*gconst0*gconst10*gconst5*py))+(((2.0)*gconst1*gconst11*gconst2*px))+(((0.00174496)*gconst0*gconst7*(py*py)))+(((-1.948726657024e-6)*gconst1*px))+(((-2.0)*gconst0*gconst11*gconst3*px))+(((7.612213504e-7)*gconst1*gconst6*py*sj2))+(((0.0022335488)*gconst3*py*(sj2*sj2)))+(((4.0)*gconst3*gconst6*px*py))+(((0.0022335488)*gconst6*py*(sj2*sj2)))+(((0.0011167744)*gconst10*px*sj2))+(((0.0022335488)*gconst3*px*sj2))+(((-2.0)*gconst5*gconst6*gconst8*px))+(((4.0)*gconst2*gconst7*px*py))+(((-0.00174496)*gconst1*gconst7*(py*py)))+(((0.00174496)*gconst3*gconst4*(py*py)))+(((-2.0)*gconst10*gconst2*gconst5*px))+(((-1.948726657024e-6)*gconst4*py*sj2)));
op[6]=(((gconst0*x111*x80))+(((-1.0)*gconst3*gconst7*x147))+((x110*x76))+(((-1.28)*x66*x80))+((gconst5*gconst6*x76))+((x123*x147))+(((-1.0)*x174))+((x117*x155))+(((-0.64)*x108*x66))+((gconst0*gconst3*x69))+((x147*x80))+((gconst5*x111*x80))+(((-1.0)*gconst0*gconst4*x155))+((gconst6*x130*x82))+(((-1.0)*gconst2*x126*x86))+(((-1.0)*gconst1*x70))+(((-1.0)*x82*x94))+((x101*x73))+x173+(((0.00348992)*x86*x87))+((px*x126*x76))+(((-1.0)*gconst6*x87*x92))+((x75*x77))+(((-1.0)*gconst7*x116*x76))+(((-1.0)*x101*x69))+(((-1.0)*x75*x76))+(((-1.0)*gconst6*x111*x87))+(((-1.0)*gconst3*x116*x73))+((gconst2*x111*x75))+((gconst1*gconst4*x155))+(((-1.0)*gconst9*x116*x75))+((x104*x117))+(((-1.0)*x111*x154))+(((0.00348992)*gconst0*gconst7*x86))+(((-1.0)*gconst3*x111*x75))+(((-1.0)*x113*x71))+(((-1.0)*gconst5*x130*x76))+((x118*x120))+(((-0.00348992)*x110*x86))+((x123*x82))+(((-0.64)*x104*x66))+((x120*x88))+((x103*x75))+(((-1.0)*x147*x94))+(((-1.0)*x113*x155))+(((-1.0)*gconst2*x111*x88))+((gconst7*x101*x111))+(((-1.0)*gconst7*x130*x82)));
op[7]=(((gconst7*x101*x89))+((gconst2*x75*x89))+((gconst4*x76*x85))+(((-1.0)*x154*x89))+(((-1.0)*gconst3*x75*x89))+((py*x75*x85))+(((-1.0)*x171))+(((0.00174496)*x82*x87))+((gconst5*x80*x89))+(((-1.0)*gconst2*x82*x98))+x172+(((-1.0)*gconst6*x87*x89))+((gconst6*x109*x82))+((gconst0*x80*x89))+(((-1.0)*gconst6*x85*x99))+(((-0.00174496)*x75*x82))+(((-1.0)*gconst2*x88*x89))+(((-1.0)*gconst5*x76*x85)));
op[8]=((((-0.64)*x66*x80))+((x117*x80))+(((-1.0)*gconst1*x115))+((x101*x75))+(((-1.0)*x87*x88))+(((-1.0)*gconst3*x116*x75))+((x88*x96))+((x118*x96)));
polyroots8(op,zeror,numroots);
IkReal j0array[8], cj0array[8], sj0array[8], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[8]={true,true,true,true,true,true,true,true};
_nj0 = 8;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j1eval[2];
IkReal x175=py*py;
IkReal x176=cj0*cj0;
IkReal x177=pz*pz;
IkReal x178=px*px;
IkReal x179=((0.0007328832)*sj2);
IkReal x180=(py*sj0);
IkReal x181=(cj0*px);
IkReal x182=((4584.63231248854)*sj2);
IkReal x183=(sj2*x176);
IkReal x184=((0.84)*x175);
IkReal x185=(sj2*x177);
IkReal x186=((5254713.3601785)*x175);
j1eval[0]=((((-5254713.3601785)*x185))+(((-1.0)*sj2))+(((-5254713.3601785)*x178*x183))+(((-10509426.720357)*sj2*x180*x181))+(((-1.0)*x180*x182))+(((-1.0)*sj2*x186))+((x183*x186))+(((-1.0)*x181*x182)));
j1eval[1]=IKsign(((((-1.68)*sj2*x180*x181))+(((-1.59856483584e-7)*sj2))+(((-0.84)*x178*x183))+(((-1.0)*sj2*x184))+(((-1.0)*x179*x181))+(((-1.0)*x179*x180))+(((-0.84)*x185))+((x183*x184))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
j3eval[0]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
if( (((-1.00118993613453)+(((2.9761888707923)*pp))+(((0.00259666526598887)*cj0*px))+(((0.00259666526598887)*py*sj0)))) < -1-IKFAST_SINCOS_THRESH || (((-1.00118993613453)+(((2.9761888707923)*pp))+(((0.00259666526598887)*cj0*px))+(((0.00259666526598887)*py*sj0)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x187=IKasin(((-1.00118993613453)+(((2.9761888707923)*pp))+(((0.00259666526598887)*cj0*px))+(((0.00259666526598887)*py*sj0))));
j3array[0]=((-1.57183499308805)+(((1.0)*x187)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((1.56975766050174)+(((-1.0)*x187)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x188=((0.000174496)*cj3);
IkReal x189=((0.00043624)*pz);
IkReal x190=((2292.31615624427)*cj3);
IkReal x191=(py*sj0);
IkReal x192=(cj0*px);
IkReal x193=((0.4)*cj3);
IkReal x194=((1.0)*pz);
IkReal x195=(pz*sj3);
IkReal x196=(x188+x189);
j1eval[0]=((-1.05)+(((-2.5)*pz))+(((-1.0)*x190*x192))+(((-1.0)*x190*x191))+(((2292.31615624427)*x195))+(((-2406.93196405648)*x191))+(((-2406.93196405648)*x192))+(((-1.0)*cj3)));
j1eval[1]=((IKabs(((-0.1764)+(((-0.336)*cj3))+(pz*pz)+(((-0.16)*(cj3*cj3))))))+(IKabs(((-0.0001832208)+(((-1.0)*x192*x194))+(((-1.0)*x191*x194))+(((0.168)*sj3))+(((-1.0)*x196))+(((0.16)*cj3*sj3))))));
j1eval[2]=IKsign(((-0.0001832208)+(((-1.0)*x192*x193))+(((0.4)*x195))+(((-1.0)*x191*x193))+(((-1.0)*x196))+(((-0.42)*x191))+(((-0.42)*x192))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=1.0;
j2=0;
j1eval[0]=((-963.919489000715)+sj3+(((-962.772785622593)*cj3)));
j1eval[1]=IKsign(((-0.336400190305338)+(((0.000348992)*sj3))+(((-0.336)*cj3))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x197=((0.4)*sj3);
IkReal x198=(cj0*px);
IkReal x199=(py*sj0);
IkReal x200=((2101885.3440714)*sj3);
IkReal x201=(cj3*pz);
IkReal x202=((1.0)*pz);
j1eval[0]=((1.0)+(((2292.31615624427)*x198))+(((2292.31615624427)*x199))+(((-916.926462497708)*sj3))+(((-2206979.61127497)*pz))+(((-1.0)*x198*x200))+(((-2101885.3440714)*x201))+(((-1.0)*x199*x200)));
j1eval[1]=((IKabs(((0.0001832208)+(((-0.168)*sj3))+(((-0.00043624)*pz))+(((-1.0)*x198*x202))+(((0.000174496)*cj3))+(((-1.0)*x199*x202))+(((-0.16)*cj3*sj3)))))+(IKabs(((0.160000190305338)+(((-1.0)*pz*x202))+(((-0.16)*(cj3*cj3)))+(((-0.000348992)*sj3))))));
j1eval[2]=IKsign(((1.903053376e-7)+(((-0.4)*x201))+(((0.00043624)*x199))+(((0.00043624)*x198))+(((-1.0)*x197*x199))+(((-1.0)*x197*x198))+(((-0.000174496)*sj3))+(((-0.42)*pz))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x203=(py*sj0);
IkReal x204=((1.0)*pz);
IkReal x205=((0.4)*sj3);
IkReal x206=(cj0*px);
CheckValue<IkReal> x207 = IKatan2WithCheck(IkReal(((0.0001832208)+(((-1.0)*x204*x206))+(((-1.0)*x203*x204))+(((-0.168)*sj3))+(((-0.00043624)*pz))+(((0.000174496)*cj3))+(((-0.16)*cj3*sj3)))),IkReal(((0.160000190305338)+(((-1.0)*pz*x204))+(((-0.16)*(cj3*cj3)))+(((-0.000348992)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x207.valid){
continue;
}
CheckValue<IkReal> x208=IKPowWithIntegerCheck(IKsign(((1.903053376e-7)+(((-1.0)*x203*x205))+(((0.00043624)*x203))+(((0.00043624)*x206))+(((-1.0)*x205*x206))+(((-0.000174496)*sj3))+(((-0.42)*pz))+(((-0.4)*cj3*pz)))),-1);
if(!x208.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x207.value)+(((1.5707963267949)*(x208.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x209=IKsin(j1);
IkReal x210=IKcos(j1);
IkReal x211=((0.4)*cj3);
IkReal x212=(cj0*px);
IkReal x213=(py*sj0);
IkReal x214=((0.4)*sj3);
IkReal x215=((0.00043624)*x209);
IkReal x216=((0.00043624)*x210);
IkReal x217=((1.0)*x209);
IkReal x218=((1.0)*x210);
IkReal x219=((0.00087248)*x213);
IkReal x220=((0.84)*x209);
IkReal x221=(pz*x209);
evalcond[0]=((((-0.42)*x210))+x215+(((-1.0)*x210*x211))+pz+(((-1.0)*x209*x214)));
evalcond[1]=((0.00043624)+x221+(((-1.0)*x213*x218))+(((-1.0)*x212*x218))+(((-1.0)*x216))+(((-1.0)*x214)));
evalcond[2]=((0.42)+(((-1.0)*pz*x218))+x211+(((-1.0)*x213*x217))+(((-1.0)*x212*x217))+(((-1.0)*x215)));
evalcond[3]=((-0.00043624)+(((0.42)*x209))+((x209*x211))+x216+(((-1.0)*x210*x214))+(((-1.0)*x213))+(((-1.0)*x212)));
evalcond[4]=((-0.0164003806106752)+(((0.00087248)*x210*x212))+(((-0.00087248)*x221))+(((-0.00087248)*x212))+((x210*x219))+(((0.84)*pz*x210))+(((0.0003664416)*x209))+(((3.806106752e-7)*x210))+((x213*x220))+(((-1.0)*pp))+(((-1.0)*x219))+((x212*x220)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x799=(py*sj0);
IkReal x800=(cj0*px);
IkReal x801=((0.4)*cj3);
IkReal x802=((0.4)*sj3);
CheckValue<IkReal> x803=IKPowWithIntegerCheck(IKsign(((-0.336400190305338)+(((0.000348992)*sj3))+(((-0.336)*cj3)))),-1);
if(!x803.valid){
continue;
}
CheckValue<IkReal> x804 = IKatan2WithCheck(IkReal(((-0.0001832208)+(((-1.0)*x799*x801))+(((-0.42)*x800))+(((-0.000174496)*cj3))+(((-1.0)*x800*x801))+(((-0.42)*x799))+(((0.00043624)*pz))+(((-1.0)*pz*x802)))),IkReal(((-1.903053376e-7)+((x800*x802))+((x799*x802))+(((-0.00043624)*x800))+(((0.000174496)*sj3))+(((-0.00043624)*x799))+(((-0.42)*pz))+(((-1.0)*pz*x801)))),IKFAST_ATAN2_MAGTHRESH);
if(!x804.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x803.value)))+(x804.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x805=IKsin(j1);
IkReal x806=IKcos(j1);
IkReal x807=((0.4)*cj3);
IkReal x808=(cj0*px);
IkReal x809=(py*sj0);
IkReal x810=((0.4)*sj3);
IkReal x811=((0.00043624)*x805);
IkReal x812=((0.00043624)*x806);
IkReal x813=((1.0)*x805);
IkReal x814=((1.0)*x806);
IkReal x815=((0.00087248)*x809);
IkReal x816=((0.84)*x805);
IkReal x817=(pz*x805);
evalcond[0]=((((-1.0)*x806*x807))+(((-0.42)*x806))+pz+x811+(((-1.0)*x805*x810)));
evalcond[1]=((0.00043624)+(((-1.0)*x808*x814))+(((-1.0)*x809*x814))+(((-1.0)*x810))+(((-1.0)*x812))+x817);
evalcond[2]=((0.42)+(((-1.0)*x808*x813))+(((-1.0)*x809*x813))+(((-1.0)*pz*x814))+(((-1.0)*x811))+x807);
evalcond[3]=((-0.00043624)+(((-1.0)*x808))+(((-1.0)*x809))+((x805*x807))+(((0.42)*x805))+x812+(((-1.0)*x806*x810)));
evalcond[4]=((-0.0164003806106752)+(((0.84)*pz*x806))+((x809*x816))+(((0.0003664416)*x805))+(((-1.0)*x815))+((x808*x816))+(((-0.00087248)*x808))+(((-1.0)*pp))+(((0.00087248)*x806*x808))+(((3.806106752e-7)*x806))+((x806*x815))+(((-0.00087248)*x817)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x818=((0.000174496)*cj3);
IkReal x819=((0.00043624)*pz);
IkReal x820=(py*sj0);
IkReal x821=(cj0*px);
IkReal x822=((0.4)*cj3);
IkReal x823=((1.0)*pz);
IkReal x824=(x818+x819);
CheckValue<IkReal> x825=IKPowWithIntegerCheck(IKsign(((-0.0001832208)+(((-1.0)*x824))+(((-1.0)*x821*x822))+(((-1.0)*x820*x822))+(((0.4)*pz*sj3))+(((-0.42)*x820))+(((-0.42)*x821)))),-1);
if(!x825.valid){
continue;
}
CheckValue<IkReal> x826 = IKatan2WithCheck(IkReal(((-0.1764)+(((-0.336)*cj3))+(pz*pz)+(((-0.16)*(cj3*cj3))))),IkReal(((-0.0001832208)+(((0.168)*sj3))+(((-1.0)*x824))+(((-1.0)*x821*x823))+(((-1.0)*x820*x823))+(((0.16)*cj3*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x826.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x825.value)))+(x826.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x827=IKsin(j1);
IkReal x828=IKcos(j1);
IkReal x829=((0.4)*cj3);
IkReal x830=(cj0*px);
IkReal x831=(py*sj0);
IkReal x832=((0.4)*sj3);
IkReal x833=((0.00043624)*x827);
IkReal x834=((0.00043624)*x828);
IkReal x835=((1.0)*x827);
IkReal x836=((1.0)*x828);
IkReal x837=((0.00087248)*x831);
IkReal x838=((0.84)*x827);
IkReal x839=(pz*x827);
evalcond[0]=((((-1.0)*x827*x832))+(((-1.0)*x828*x829))+pz+x833+(((-0.42)*x828)));
evalcond[1]=((0.00043624)+(((-1.0)*x830*x836))+(((-1.0)*x834))+(((-1.0)*x832))+x839+(((-1.0)*x831*x836)));
evalcond[2]=((0.42)+(((-1.0)*pz*x836))+(((-1.0)*x830*x835))+(((-1.0)*x833))+x829+(((-1.0)*x831*x835)));
evalcond[3]=((-0.00043624)+(((-1.0)*x828*x832))+(((0.42)*x827))+(((-1.0)*x831))+(((-1.0)*x830))+x834+((x827*x829)));
evalcond[4]=((-0.0164003806106752)+((x831*x838))+(((3.806106752e-7)*x828))+(((0.84)*pz*x828))+(((-1.0)*pp))+(((-1.0)*x837))+((x830*x838))+(((-0.00087248)*x830))+(((-0.00087248)*x839))+(((0.0003664416)*x827))+((x828*x837))+(((0.00087248)*x828*x830)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
if( (((-1.00118993613453)+(((2.9761888707923)*pp))+(((0.00259666526598887)*cj0*px))+(((0.00259666526598887)*py*sj0)))) < -1-IKFAST_SINCOS_THRESH || (((-1.00118993613453)+(((2.9761888707923)*pp))+(((0.00259666526598887)*cj0*px))+(((0.00259666526598887)*py*sj0)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x840=IKasin(((-1.00118993613453)+(((2.9761888707923)*pp))+(((0.00259666526598887)*cj0*px))+(((0.00259666526598887)*py*sj0))));
j3array[0]=((-1.57183499308805)+(((1.0)*x840)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((1.56975766050174)+(((-1.0)*x840)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x841=((0.000174496)*cj3);
IkReal x842=((0.00043624)*pz);
IkReal x843=((2292.31615624427)*cj3);
IkReal x844=(py*sj0);
IkReal x845=(cj0*px);
IkReal x846=((0.4)*cj3);
IkReal x847=(pz*sj3);
IkReal x848=((1.0)*pz);
j1eval[0]=((-1.05)+(((-2292.31615624427)*x847))+(((-1.0)*x843*x845))+(((-1.0)*x843*x844))+(((-2406.93196405648)*x844))+(((-2406.93196405648)*x845))+(((-1.0)*cj3))+(((2.5)*pz)));
j1eval[1]=IKsign(((-0.0001832208)+(((-0.42)*x844))+(((-0.42)*x845))+(((-0.4)*x847))+(((-1.0)*x841))+(((-1.0)*x844*x846))+(((-1.0)*x845*x846))+x842));
j1eval[2]=((IKabs(((-0.1764)+(((-0.336)*cj3))+(pz*pz)+(((-0.16)*(cj3*cj3))))))+(IKabs(((0.0001832208)+(((-0.168)*sj3))+(((-1.0)*x842))+(((-1.0)*x844*x848))+(((-1.0)*x845*x848))+(((-0.16)*cj3*sj3))+x841))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j1eval[0]=((-963.919489000715)+sj3+(((-962.772785622593)*cj3)));
j1eval[1]=IKsign(((-0.336400190305338)+(((0.000348992)*sj3))+(((-0.336)*cj3))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x849=((0.4)*sj3);
IkReal x850=(cj0*px);
IkReal x851=(py*sj0);
IkReal x852=((2101885.3440714)*sj3);
IkReal x853=(cj3*pz);
IkReal x854=((1.0)*pz);
j1eval[0]=((-1.0)+((x850*x852))+(((916.926462497708)*sj3))+(((-2206979.61127497)*pz))+((x851*x852))+(((-2292.31615624427)*x851))+(((-2292.31615624427)*x850))+(((-2101885.3440714)*x853)));
j1eval[1]=IKsign(((-1.903053376e-7)+(((-0.00043624)*x850))+(((-0.00043624)*x851))+(((0.000174496)*sj3))+(((-0.4)*x853))+((x849*x851))+((x849*x850))+(((-0.42)*pz))));
j1eval[2]=((IKabs(((-0.0001832208)+(((-1.0)*x850*x854))+(((0.168)*sj3))+(((-0.000174496)*cj3))+(((-0.00043624)*pz))+(((-1.0)*x851*x854))+(((0.16)*cj3*sj3)))))+(IKabs(((0.160000190305338)+(((-0.16)*(cj3*cj3)))+(((-1.0)*pz*x854))+(((-0.000348992)*sj3))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x855=((0.4)*sj3);
IkReal x856=(cj0*px);
IkReal x857=(py*sj0);
IkReal x858=((1.0)*pz);
CheckValue<IkReal> x859=IKPowWithIntegerCheck(IKsign(((-1.903053376e-7)+((x855*x857))+((x855*x856))+(((-0.00043624)*x857))+(((-0.00043624)*x856))+(((0.000174496)*sj3))+(((-0.42)*pz))+(((-0.4)*cj3*pz)))),-1);
if(!x859.valid){
continue;
}
CheckValue<IkReal> x860 = IKatan2WithCheck(IkReal(((-0.0001832208)+(((0.168)*sj3))+(((-0.000174496)*cj3))+(((-0.00043624)*pz))+(((-1.0)*x856*x858))+(((0.16)*cj3*sj3))+(((-1.0)*x857*x858)))),IkReal(((0.160000190305338)+(((-0.16)*(cj3*cj3)))+(((-1.0)*pz*x858))+(((-0.000348992)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x860.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x859.value)))+(x860.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x861=IKcos(j1);
IkReal x862=IKsin(j1);
IkReal x863=((0.4)*cj3);
IkReal x864=(cj0*px);
IkReal x865=(py*sj0);
IkReal x866=((0.4)*sj3);
IkReal x867=((0.00043624)*x862);
IkReal x868=((0.00043624)*x861);
IkReal x869=((1.0)*x862);
IkReal x870=(pz*x861);
IkReal x871=((0.00087248)*x865);
IkReal x872=((0.84)*x862);
evalcond[0]=((((-1.0)*x867))+(((-1.0)*x861*x863))+pz+((x862*x866))+(((-0.42)*x861)));
evalcond[1]=((0.00043624)+(((-1.0)*x866))+(((-1.0)*pz*x869))+((x861*x864))+((x861*x865))+x868);
evalcond[2]=((0.42)+(((-1.0)*x867))+(((-1.0)*x865*x869))+(((-1.0)*x870))+(((-1.0)*x864*x869))+x863);
evalcond[3]=((-0.00043624)+(((-1.0)*x868))+(((-1.0)*x865))+(((-1.0)*x864))+(((0.42)*x862))+((x862*x863))+((x861*x866)));
evalcond[4]=((-0.0164003806106752)+(((0.84)*x870))+(((-3.806106752e-7)*x861))+(((-0.00087248)*x864))+(((-0.00087248)*x861*x864))+(((-1.0)*x861*x871))+(((-1.0)*pp))+(((0.0003664416)*x862))+((x864*x872))+((x865*x872))+(((0.00087248)*pz*x862))+(((-1.0)*x871)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x873=(cj0*px);
IkReal x874=((0.4)*sj3);
IkReal x875=(py*sj0);
IkReal x876=((0.4)*cj3);
CheckValue<IkReal> x877=IKPowWithIntegerCheck(IKsign(((-0.336400190305338)+(((0.000348992)*sj3))+(((-0.336)*cj3)))),-1);
if(!x877.valid){
continue;
}
CheckValue<IkReal> x878 = IKatan2WithCheck(IkReal(((-0.0001832208)+(((-1.0)*x873*x876))+(((-0.000174496)*cj3))+(((-0.00043624)*pz))+(((-1.0)*x875*x876))+(((-0.42)*x875))+(((-0.42)*x873))+((pz*x874)))),IkReal(((1.903053376e-7)+(((-1.0)*x873*x874))+(((-1.0)*pz*x876))+(((-1.0)*x874*x875))+(((0.00043624)*x875))+(((0.00043624)*x873))+(((-0.000174496)*sj3))+(((-0.42)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x878.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x877.value)))+(x878.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x879=IKcos(j1);
IkReal x880=IKsin(j1);
IkReal x881=((0.4)*cj3);
IkReal x882=(cj0*px);
IkReal x883=(py*sj0);
IkReal x884=((0.4)*sj3);
IkReal x885=((0.00043624)*x880);
IkReal x886=((0.00043624)*x879);
IkReal x887=((1.0)*x880);
IkReal x888=(pz*x879);
IkReal x889=((0.00087248)*x883);
IkReal x890=((0.84)*x880);
evalcond[0]=((((-1.0)*x879*x881))+((x880*x884))+(((-1.0)*x885))+pz+(((-0.42)*x879)));
evalcond[1]=((0.00043624)+((x879*x882))+((x879*x883))+(((-1.0)*pz*x887))+(((-1.0)*x884))+x886);
evalcond[2]=((0.42)+(((-1.0)*x883*x887))+(((-1.0)*x882*x887))+(((-1.0)*x888))+(((-1.0)*x885))+x881);
evalcond[3]=((-0.00043624)+(((0.42)*x880))+((x879*x884))+((x880*x881))+(((-1.0)*x883))+(((-1.0)*x882))+(((-1.0)*x886)));
evalcond[4]=((-0.0164003806106752)+(((-1.0)*x879*x889))+((x882*x890))+(((-3.806106752e-7)*x879))+(((0.84)*x888))+((x883*x890))+(((-1.0)*x889))+(((-1.0)*pp))+(((0.00087248)*pz*x880))+(((-0.00087248)*x879*x882))+(((0.0003664416)*x880))+(((-0.00087248)*x882)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x891=((0.00043624)*pz);
IkReal x892=((0.000174496)*cj3);
IkReal x893=(py*sj0);
IkReal x894=(cj0*px);
IkReal x895=((0.4)*cj3);
IkReal x896=((1.0)*pz);
CheckValue<IkReal> x897=IKPowWithIntegerCheck(IKsign(((-0.0001832208)+(((-0.4)*pz*sj3))+(((-1.0)*x892))+(((-1.0)*x894*x895))+(((-1.0)*x893*x895))+x891+(((-0.42)*x893))+(((-0.42)*x894)))),-1);
if(!x897.valid){
continue;
}
CheckValue<IkReal> x898 = IKatan2WithCheck(IkReal(((-0.1764)+(((-0.336)*cj3))+(pz*pz)+(((-0.16)*(cj3*cj3))))),IkReal(((0.0001832208)+(((-1.0)*x891))+(((-0.168)*sj3))+(((-1.0)*x894*x896))+(((-1.0)*x893*x896))+(((-0.16)*cj3*sj3))+x892)),IKFAST_ATAN2_MAGTHRESH);
if(!x898.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x897.value)))+(x898.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x899=IKcos(j1);
IkReal x900=IKsin(j1);
IkReal x901=((0.4)*cj3);
IkReal x902=(cj0*px);
IkReal x903=(py*sj0);
IkReal x904=((0.4)*sj3);
IkReal x905=((0.00043624)*x900);
IkReal x906=((0.00043624)*x899);
IkReal x907=((1.0)*x900);
IkReal x908=(pz*x899);
IkReal x909=((0.00087248)*x903);
IkReal x910=((0.84)*x900);
evalcond[0]=((((-1.0)*x905))+((x900*x904))+pz+(((-1.0)*x899*x901))+(((-0.42)*x899)));
evalcond[1]=((0.00043624)+(((-1.0)*pz*x907))+(((-1.0)*x904))+((x899*x903))+((x899*x902))+x906);
evalcond[2]=((0.42)+(((-1.0)*x903*x907))+(((-1.0)*x902*x907))+(((-1.0)*x905))+(((-1.0)*x908))+x901);
evalcond[3]=((-0.00043624)+(((-1.0)*x906))+((x900*x901))+((x899*x904))+(((-1.0)*x902))+(((-1.0)*x903))+(((0.42)*x900)));
evalcond[4]=((-0.0164003806106752)+((x902*x910))+(((-1.0)*x909))+((x903*x910))+(((-0.00087248)*x902))+(((0.84)*x908))+(((-1.0)*pp))+(((-0.00087248)*x899*x902))+(((0.0003664416)*x900))+(((0.00087248)*pz*x900))+(((-3.806106752e-7)*x899))+(((-1.0)*x899*x909)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x915=IKPowWithIntegerCheck(sj2,-1);
if(!x915.valid){
continue;
}
IkReal x911=x915.value;
IkReal x912=((5453.0)*sj2);
IkReal x913=(px*sj0);
IkReal x914=(cj0*py);
if( IKabs(((0.5)*x911*(((((0.0021812)*sj2))+(((5.0)*x913))+(((-5.0)*x914)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((4.76190476190476e-7)*x911*((((py*sj0*x912))+((cj0*px*x912))+(((5453.0)*x913))+(((-2102497.62118328)*sj2))+(((6250000.0)*pp*sj2))+(((-5453.0)*x914)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.5)*x911*(((((0.0021812)*sj2))+(((5.0)*x913))+(((-5.0)*x914))))))+IKsqr(((4.76190476190476e-7)*x911*((((py*sj0*x912))+((cj0*px*x912))+(((5453.0)*x913))+(((-2102497.62118328)*sj2))+(((6250000.0)*pp*sj2))+(((-5453.0)*x914))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.5)*x911*(((((0.0021812)*sj2))+(((5.0)*x913))+(((-5.0)*x914))))), ((4.76190476190476e-7)*x911*((((py*sj0*x912))+((cj0*px*x912))+(((5453.0)*x913))+(((-2102497.62118328)*sj2))+(((6250000.0)*pp*sj2))+(((-5453.0)*x914))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x916=IKsin(j3);
evalcond[0]=((((0.00043624)*sj2))+(((-0.4)*sj2*x916))+((px*sj0))+(((-1.0)*cj0*py)));
evalcond[1]=((0.3364)+(((-0.000348992)*x916))+(((-1.0)*pp))+(((0.336)*(IKcos(j3))))+(((-0.00087248)*cj0*px))+(((-0.00087248)*py*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x917=((2292.31615624427)*cj3);
IkReal x918=(py*sj0);
IkReal x919=(cj0*px);
IkReal x920=(cj2*pz);
IkReal x921=((0.4)*cj3);
j1eval[0]=((-1.05)+(((2292.31615624427)*sj3*x920))+(((-2.5)*x920))+(((-2406.93196405648)*x918))+(((-2406.93196405648)*x919))+(((-1.0)*cj3))+(((-1.0)*x917*x919))+(((-1.0)*x917*x918)));
j1eval[1]=IKsign(((-0.0001832208)+(((-0.42)*x918))+(((-0.42)*x919))+(((-0.000174496)*cj3))+(((-1.0)*x918*x921))+(((-0.00043624)*x920))+(((-1.0)*x919*x921))+(((0.4)*sj3*x920))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x922=cj2*cj2;
IkReal x923=cj3*cj3;
IkReal x924=((458.463231248854)*x923);
IkReal x925=((0.16)*x923);
IkReal x926=(sj3*x922);
j1eval[0]=((-505.455712451861)+(((-1.0)*x924))+(((-458.463776548854)*x922))+(((-962.772785622593)*cj3))+((x922*x924))+x926);
j1eval[1]=IKsign(((-0.1764)+(((-1.0)*x925))+(((-0.160000190305338)*x922))+(((0.000348992)*x926))+(((-0.336)*cj3))+((x922*x925))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x927=(cj2*sj3);
IkReal x928=(cj3*pz);
IkReal x929=(cj0*px);
IkReal x930=(py*sj0);
IkReal x931=((0.00043624)*cj2);
IkReal x932=((2292.31615624427)*cj2);
j1eval[0]=(cj2+(((-2206979.61127497)*pz))+((x930*x932))+(((-916.926462497708)*x927))+(((-2101885.3440714)*x927*x930))+(((-2101885.3440714)*x927*x929))+(((-2101885.3440714)*x928))+((x929*x932)));
j1eval[1]=IKsign(((((-0.4)*x928))+((x930*x931))+(((-0.000174496)*x927))+(((-0.4)*x927*x930))+(((-0.4)*x927*x929))+(((1.903053376e-7)*cj2))+((x929*x931))+(((-0.42)*pz))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x933=((-1.0)*py);
pz=0;
j2=1.5707963267949;
sj2=1.0;
cj2=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x933);
rxp0_1=(px*r20);
rxp1_0=(r21*x933);
rxp1_1=(px*r21);
rxp2_0=(r22*x933);
rxp2_1=(px*r22);
j1eval[0]=((-1.0)+(((-2292.31615624427)*py*sj0))+(((-2292.31615624427)*cj0*px)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x934=((-1.0)*py);
pz=0;
j2=1.5707963267949;
sj2=1.0;
cj2=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x934);
rxp0_1=(px*r20);
rxp1_0=(r21*x934);
rxp1_1=(px*r21);
rxp2_0=(r22*x934);
rxp2_1=(px*r22);
j1eval[0]=((1.05)+cj3);
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x935=((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px))));
if((x935) < -0.00001)
continue;
IkReal x936=IKabs(IKsqrt(x935));
IkReal x941 = x935;
if(IKabs(x941)==0){
continue;
}
IkReal x937=pow(x941,-0.5);
IkReal x938=((2292.31615624427)*x937);
CheckValue<IkReal> x942=IKPowWithIntegerCheck(x936,-1);
if(!x942.valid){
continue;
}
IkReal x939=x942.value;
if((((1.0)+(((-1.0)*(x939*x939))))) < -0.00001)
continue;
IkReal x940=IKsqrt(((1.0)+(((-1.0)*(x939*x939)))));
CheckValue<IkReal> x943 = IKatan2WithCheck(IkReal(((-2292.31615624427)*px)),IkReal(((-2292.31615624427)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x943.valid){
continue;
}
if( (x939) < -1-IKFAST_SINCOS_THRESH || (x939) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst28=((((-1.0)*(x943.value)))+(IKasin(x939)));
IkReal gconst29=(((px*x938*x940))+(((-1.0)*py*x938*x939)));
IkReal gconst30=((((-1.0)*py*x938*x940))+(((-1.0)*px*x938*x939)));
if((((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x944=IKPowWithIntegerCheck(IKabs(IKsqrt(((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px)))))),-1);
if(!x944.valid){
continue;
}
if( (x944.value) < -1-IKFAST_SINCOS_THRESH || (x944.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x945 = IKatan2WithCheck(IkReal(((-2292.31615624427)*px)),IkReal(((-2292.31615624427)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x945.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*(IKasin(x944.value))))+(x945.value)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x947=IKPowWithIntegerCheck(((-0.00043624)+(((-1.0)*gconst29*py))+(((-1.0)*gconst30*px))),-1);
if(!x947.valid){
continue;
}
IkReal x946=x947.value;
sj1array[0]=((((-0.42)*x946))+(((-0.4)*cj3*x946)));
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x948=IKcos(j1);
IkReal x949=IKsin(j1);
IkReal x950=(gconst30*px);
IkReal x951=(gconst29*py);
IkReal x952=((0.4)*cj3);
IkReal x953=((0.84)*x949);
IkReal x954=((1.0)*x948);
evalcond[0]=((((-0.42)*x948))+(((-1.0)*x948*x952)));
evalcond[1]=((((-1.0)*x950*x954))+(((-1.0)*x951*x954))+(((-0.00043624)*x948)));
evalcond[2]=((-0.00043624)+(((0.42)*x949))+((x949*x952))+(((-1.0)*x951))+(((-1.0)*x950)));
evalcond[3]=((-0.0164003806106752)+((x951*x953))+(((-1.0)*(px*px)))+(((-0.00087248)*gconst29*px))+(((0.00087248)*gconst30*py))+(((0.0003664416)*x949))+(((-1.0)*(py*py)))+(((-0.00087248)*x950))+(((-0.00087248)*x951))+((x950*x953)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x955=((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px))));
IkReal x961 = x955;
if(IKabs(x961)==0){
continue;
}
IkReal x956=pow(x961,-0.5);
if((x955) < -0.00001)
continue;
IkReal x957=IKabs(IKsqrt(x955));
IkReal x958=((2292.31615624427)*x956);
CheckValue<IkReal> x962=IKPowWithIntegerCheck(x957,-1);
if(!x962.valid){
continue;
}
IkReal x959=x962.value;
if((((1.0)+(((-1.0)*(x959*x959))))) < -0.00001)
continue;
IkReal x960=IKsqrt(((1.0)+(((-1.0)*(x959*x959)))));
CheckValue<IkReal> x963 = IKatan2WithCheck(IkReal(((-2292.31615624427)*px)),IkReal(((-2292.31615624427)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x963.valid){
continue;
}
if( (x959) < -1-IKFAST_SINCOS_THRESH || (x959) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst31=((3.14159265358979)+(((-1.0)*(x963.value)))+(((-1.0)*(IKasin(x959)))));
IkReal gconst32=((((-1.0)*py*x958*x959))+(((-1.0)*px*x958*x960)));
IkReal gconst33=(((py*x958*x960))+(((-1.0)*px*x958*x959)));
CheckValue<IkReal> x964 = IKatan2WithCheck(IkReal(((-2292.31615624427)*px)),IkReal(((-2292.31615624427)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x964.valid){
continue;
}
if((((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x965=IKPowWithIntegerCheck(IKabs(IKsqrt(((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px)))))),-1);
if(!x965.valid){
continue;
}
if( (x965.value) < -1-IKFAST_SINCOS_THRESH || (x965.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x964.value)+(IKasin(x965.value))+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x967=IKPowWithIntegerCheck(((-0.00043624)+(((-1.0)*gconst33*px))+(((-1.0)*gconst32*py))),-1);
if(!x967.valid){
continue;
}
IkReal x966=x967.value;
sj1array[0]=((((-0.4)*cj3*x966))+(((-0.42)*x966)));
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x968=IKcos(j1);
IkReal x969=IKsin(j1);
IkReal x970=(gconst33*px);
IkReal x971=((0.4)*cj3);
IkReal x972=((0.00087248)*gconst32);
IkReal x973=(gconst32*py);
IkReal x974=((1.0)*x968);
IkReal x975=((0.84)*x969);
evalcond[0]=((((-1.0)*x968*x971))+(((-0.42)*x968)));
evalcond[1]=((((-1.0)*x970*x974))+(((-0.00043624)*x968))+(((-1.0)*x973*x974)));
evalcond[2]=((-0.00043624)+((x969*x971))+(((-1.0)*x970))+(((-1.0)*x973))+(((0.42)*x969)));
evalcond[3]=((-0.0164003806106752)+(((-1.0)*px*x972))+(((-1.0)*(px*px)))+(((-1.0)*py*x972))+(((0.0003664416)*x969))+((x973*x975))+(((-0.00087248)*x970))+((x970*x975))+(((0.00087248)*gconst33*py))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x977=IKPowWithIntegerCheck(((0.42)+(((0.4)*cj3))),-1);
if(!x977.valid){
continue;
}
IkReal x976=x977.value;
sj1array[0]=((((0.00043624)*x976))+((cj0*px*x976))+((py*sj0*x976)));
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x978=IKcos(j1);
IkReal x979=IKsin(j1);
IkReal x980=((0.4)*cj3);
IkReal x981=(cj0*px);
IkReal x982=(py*sj0);
IkReal x983=((1.0)*x979);
IkReal x984=((1.0)*x978);
IkReal x985=((0.84)*x979);
evalcond[0]=((((-1.0)*x978*x980))+(((-0.42)*x978)));
evalcond[1]=((((-0.00043624)*x978))+(((-1.0)*x982*x984))+(((-1.0)*x981*x984)));
evalcond[2]=((0.42)+(((-0.00043624)*x979))+(((-1.0)*x982*x983))+(((-1.0)*x981*x983))+x980);
evalcond[3]=((-0.0164003806106752)+((x981*x985))+(((-1.0)*(px*px)))+(((0.0003664416)*x979))+((x982*x985))+(((0.00087248)*cj0*py))+(((-0.00087248)*px*sj0))+(((-0.00087248)*x981))+(((-0.00087248)*x982))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x987=IKPowWithIntegerCheck(((-0.00043624)+(((-1.0)*py*sj0))+(((-1.0)*cj0*px))),-1);
if(!x987.valid){
continue;
}
IkReal x986=x987.value;
sj1array[0]=((((-0.42)*x986))+(((-0.4)*cj3*x986)));
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x988=IKcos(j1);
IkReal x989=IKsin(j1);
IkReal x990=((0.4)*cj3);
IkReal x991=(cj0*px);
IkReal x992=(py*sj0);
IkReal x993=((1.0)*x991);
IkReal x994=((0.84)*x989);
evalcond[0]=((((-0.42)*x988))+(((-1.0)*x988*x990)));
evalcond[1]=((((-0.00043624)*x988))+(((-1.0)*x988*x992))+(((-1.0)*x988*x993)));
evalcond[2]=((-0.00043624)+(((-1.0)*x992))+((x989*x990))+(((0.42)*x989))+(((-1.0)*x993)));
evalcond[3]=((-0.0164003806106752)+(((-1.0)*(px*px)))+((x991*x994))+((x992*x994))+(((-0.00087248)*x992))+(((-0.00087248)*x991))+(((0.0003664416)*x989))+(((0.00087248)*cj0*py))+(((-0.00087248)*px*sj0))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
IkReal x995=((-1.0)*py);
pz=0;
j2=-1.5707963267949;
sj2=-1.0;
cj2=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x995);
rxp0_1=(px*r20);
rxp1_0=(r21*x995);
rxp1_1=(px*r21);
rxp2_0=(r22*x995);
rxp2_1=(px*r22);
j1eval[0]=((-1.0)+(((-2292.31615624427)*py*sj0))+(((-2292.31615624427)*cj0*px)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x996=((-1.0)*py);
pz=0;
j2=-1.5707963267949;
sj2=-1.0;
cj2=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x996);
rxp0_1=(px*r20);
rxp1_0=(r21*x996);
rxp1_1=(px*r21);
rxp2_0=(r22*x996);
rxp2_1=(px*r22);
j1eval[0]=((1.05)+cj3);
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x997=((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px))));
if((x997) < -0.00001)
continue;
IkReal x998=IKabs(IKsqrt(x997));
IkReal x1003 = x997;
if(IKabs(x1003)==0){
continue;
}
IkReal x999=pow(x1003,-0.5);
IkReal x1000=((2292.31615624427)*x999);
CheckValue<IkReal> x1004=IKPowWithIntegerCheck(x998,-1);
if(!x1004.valid){
continue;
}
IkReal x1001=x1004.value;
if((((1.0)+(((-1.0)*(x1001*x1001))))) < -0.00001)
continue;
IkReal x1002=IKsqrt(((1.0)+(((-1.0)*(x1001*x1001)))));
if( (x1001) < -1-IKFAST_SINCOS_THRESH || (x1001) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1005 = IKatan2WithCheck(IkReal(((-2292.31615624427)*px)),IkReal(((-2292.31615624427)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x1005.valid){
continue;
}
IkReal gconst34=((IKasin(x1001))+(((-1.0)*(x1005.value))));
IkReal gconst35=((((-1.0)*py*x1000*x1001))+((px*x1000*x1002)));
IkReal gconst36=((((-1.0)*py*x1000*x1002))+(((-1.0)*px*x1000*x1001)));
if((((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x1006=IKPowWithIntegerCheck(IKabs(IKsqrt(((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px)))))),-1);
if(!x1006.valid){
continue;
}
if( (x1006.value) < -1-IKFAST_SINCOS_THRESH || (x1006.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1007 = IKatan2WithCheck(IkReal(((-2292.31615624427)*px)),IkReal(((-2292.31615624427)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x1007.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*(IKasin(x1006.value))))+(x1007.value)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1009=IKPowWithIntegerCheck(((-0.00043624)+(((-1.0)*gconst36*px))+(((-1.0)*gconst35*py))),-1);
if(!x1009.valid){
continue;
}
IkReal x1008=x1009.value;
sj1array[0]=((((-0.4)*cj3*x1008))+(((-0.42)*x1008)));
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1010=IKcos(j1);
IkReal x1011=IKsin(j1);
IkReal x1012=(gconst35*py);
IkReal x1013=((0.4)*cj3);
IkReal x1014=(gconst36*px);
IkReal x1015=((0.84)*x1011);
evalcond[0]=((((-1.0)*x1010*x1013))+(((-0.42)*x1010)));
evalcond[1]=((((0.00043624)*x1010))+((x1010*x1014))+((x1010*x1012)));
evalcond[2]=((-0.00043624)+(((0.42)*x1011))+((x1011*x1013))+(((-1.0)*x1012))+(((-1.0)*x1014)));
evalcond[3]=((-0.0164003806106752)+((x1014*x1015))+(((-1.0)*(px*px)))+(((-0.00087248)*x1012))+(((-0.00087248)*x1014))+(((0.00087248)*gconst35*px))+(((-0.00087248)*gconst36*py))+((x1012*x1015))+(((0.0003664416)*x1011))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1016=((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px))));
IkReal x1022 = x1016;
if(IKabs(x1022)==0){
continue;
}
IkReal x1017=pow(x1022,-0.5);
if((x1016) < -0.00001)
continue;
IkReal x1018=IKabs(IKsqrt(x1016));
IkReal x1019=((2292.31615624427)*x1017);
CheckValue<IkReal> x1023=IKPowWithIntegerCheck(x1018,-1);
if(!x1023.valid){
continue;
}
IkReal x1020=x1023.value;
if((((1.0)+(((-1.0)*(x1020*x1020))))) < -0.00001)
continue;
IkReal x1021=IKsqrt(((1.0)+(((-1.0)*(x1020*x1020)))));
CheckValue<IkReal> x1024 = IKatan2WithCheck(IkReal(((-2292.31615624427)*px)),IkReal(((-2292.31615624427)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x1024.valid){
continue;
}
if( (x1020) < -1-IKFAST_SINCOS_THRESH || (x1020) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst37=((3.14159265358979)+(((-1.0)*(x1024.value)))+(((-1.0)*(IKasin(x1020)))));
IkReal gconst38=((((-1.0)*px*x1019*x1021))+(((-1.0)*py*x1019*x1020)));
IkReal gconst39=((((-1.0)*px*x1019*x1020))+((py*x1019*x1021)));
CheckValue<IkReal> x1025 = IKatan2WithCheck(IkReal(((-2292.31615624427)*px)),IkReal(((-2292.31615624427)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x1025.valid){
continue;
}
if((((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x1026=IKPowWithIntegerCheck(IKabs(IKsqrt(((((5254713.3601785)*(py*py)))+(((5254713.3601785)*(px*px)))))),-1);
if(!x1026.valid){
continue;
}
if( (x1026.value) < -1-IKFAST_SINCOS_THRESH || (x1026.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1025.value)+(IKasin(x1026.value))+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1028=IKPowWithIntegerCheck(((-0.00043624)+(((-1.0)*gconst38*py))+(((-1.0)*gconst39*px))),-1);
if(!x1028.valid){
continue;
}
IkReal x1027=x1028.value;
sj1array[0]=((((-0.4)*cj3*x1027))+(((-0.42)*x1027)));
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1029=IKcos(j1);
IkReal x1030=IKsin(j1);
IkReal x1031=((0.00087248)*gconst39);
IkReal x1032=((0.4)*cj3);
IkReal x1033=(gconst38*py);
IkReal x1034=(gconst39*px);
IkReal x1035=((0.84)*x1030);
evalcond[0]=((((-1.0)*x1029*x1032))+(((-0.42)*x1029)));
evalcond[1]=((((0.00043624)*x1029))+((x1029*x1033))+((x1029*x1034)));
evalcond[2]=((-0.00043624)+((x1030*x1032))+(((-1.0)*x1034))+(((-1.0)*x1033))+(((0.42)*x1030)));
evalcond[3]=((-0.0164003806106752)+(((-1.0)*(px*px)))+(((-1.0)*py*x1031))+(((-0.00087248)*x1033))+(((0.0003664416)*x1030))+((x1034*x1035))+((x1033*x1035))+(((0.00087248)*gconst38*px))+(((-1.0)*(py*py)))+(((-1.0)*px*x1031)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1037=IKPowWithIntegerCheck(((0.42)+(((0.4)*cj3))),-1);
if(!x1037.valid){
continue;
}
IkReal x1036=x1037.value;
sj1array[0]=(((py*sj0*x1036))+((cj0*px*x1036))+(((0.00043624)*x1036)));
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1038=IKcos(j1);
IkReal x1039=IKsin(j1);
IkReal x1040=((0.4)*cj3);
IkReal x1041=(cj0*px);
IkReal x1042=(py*sj0);
IkReal x1043=((1.0)*x1039);
IkReal x1044=((0.84)*x1039);
evalcond[0]=((((-1.0)*x1038*x1040))+(((-0.42)*x1038)));
evalcond[1]=(((x1038*x1042))+((x1038*x1041))+(((0.00043624)*x1038)));
evalcond[2]=((0.42)+x1040+(((-1.0)*x1041*x1043))+(((-0.00043624)*x1039))+(((-1.0)*x1042*x1043)));
evalcond[3]=((-0.0164003806106752)+(((-1.0)*(px*px)))+((x1042*x1044))+((x1041*x1044))+(((0.00087248)*px*sj0))+(((-0.00087248)*x1041))+(((-0.00087248)*x1042))+(((0.0003664416)*x1039))+(((-0.00087248)*cj0*py))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x1046=IKPowWithIntegerCheck(((-0.00043624)+(((-1.0)*py*sj0))+(((-1.0)*cj0*px))),-1);
if(!x1046.valid){
continue;
}
IkReal x1045=x1046.value;
sj1array[0]=((((-0.42)*x1045))+(((-0.4)*cj3*x1045)));
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1047=IKcos(j1);
IkReal x1048=IKsin(j1);
IkReal x1049=((0.4)*cj3);
IkReal x1050=((0.00087248)*px);
IkReal x1051=(py*sj0);
IkReal x1052=(cj0*px);
IkReal x1053=((0.84)*x1048);
evalcond[0]=((((-0.42)*x1047))+(((-1.0)*x1047*x1049)));
evalcond[1]=((((0.00043624)*x1047))+((x1047*x1051))+((x1047*x1052)));
evalcond[2]=((-0.00043624)+((x1048*x1049))+(((-1.0)*x1051))+(((-1.0)*x1052))+(((0.42)*x1048)));
evalcond[3]=((-0.0164003806106752)+(((-1.0)*(px*px)))+((x1052*x1053))+(((0.0003664416)*x1048))+((sj0*x1050))+((x1051*x1053))+(((-1.0)*cj0*x1050))+(((-0.00087248)*x1051))+(((-0.00087248)*cj0*py))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1054=cj0*cj0;
IkReal x1055=py*py;
IkReal x1056=(cj2*cj3);
IkReal x1057=(py*sj0);
IkReal x1058=(cj0*px);
IkReal x1059=(cj2*sj3);
IkReal x1060=((0.00043624)*cj2);
IkReal x1061=((1.0)*pz);
IkReal x1062=((0.4)*x1059);
CheckValue<IkReal> x1063 = IKatan2WithCheck(IkReal(((((-1.0)*x1058*x1061))+(((-1.0)*x1057*x1061))+(((0.000174496)*x1056))+(((-0.00043624)*pz))+(((0.0001832208)*cj2))+(((-0.168)*x1059))+(((-0.16)*sj3*x1056)))),IkReal(((-0.176399809694662)+(((-1.0)*x1054*x1055))+x1055+(((2.0)*x1057*x1058))+(((-0.336)*cj3))+(((-0.16)*(cj3*cj3)))+((x1054*(px*px)))+(((0.00087248)*x1057))+(((0.00087248)*x1058)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1063.valid){
continue;
}
CheckValue<IkReal> x1064=IKPowWithIntegerCheck(IKsign(((((-0.000174496)*x1059))+(((-1.0)*x1058*x1062))+((x1057*x1060))+(((-1.0)*x1057*x1062))+(((1.903053376e-7)*cj2))+(((-0.42)*pz))+(((-0.4)*cj3*pz))+((x1058*x1060)))),-1);
if(!x1064.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1063.value)+(((1.5707963267949)*(x1064.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1065=IKcos(j1);
IkReal x1066=IKsin(j1);
IkReal x1067=((0.4)*cj3);
IkReal x1068=((1.0)*px);
IkReal x1069=(cj2*sj0);
IkReal x1070=((0.4)*sj3);
IkReal x1071=(py*sj0);
IkReal x1072=(cj0*py);
IkReal x1073=((0.00087248)*px);
IkReal x1074=(px*sj0*sj2);
IkReal x1075=(cj0*x1066);
IkReal x1076=((1.0)*x1065);
IkReal x1077=(cj0*x1065);
IkReal x1078=(cj2*x1066);
IkReal x1079=(cj2*x1065);
IkReal x1080=((0.00043624)*x1079);
evalcond[0]=((((-1.0)*x1070*x1078))+(((-0.42)*x1065))+pz+(((0.00043624)*x1078))+(((-1.0)*x1065*x1067)));
evalcond[1]=((0.42)+x1067+(((-1.0)*x1066*x1071))+(((-1.0)*pz*x1076))+(((-1.0)*x1068*x1075))+(((-0.00043624)*x1066)));
evalcond[2]=((-0.00043624)+(((0.42)*x1066))+x1080+(((-1.0)*x1070*x1079))+((x1066*x1067))+(((-1.0)*cj0*x1068))+(((-1.0)*x1071)));
evalcond[3]=((((-1.0)*sj2*x1071*x1076))+(((-1.0)*sj2*x1068*x1077))+(((-0.00043624)*sj2*x1065))+((pz*sj2*x1066))+((cj2*x1072))+(((-1.0)*x1068*x1069)));
evalcond[4]=((0.00043624)+x1074+(((-1.0)*sj2*x1072))+((pz*x1078))+(((-1.0)*py*x1069*x1076))+(((-1.0)*cj2*x1068*x1077))+(((-1.0)*x1080))+(((-1.0)*x1070)));
evalcond[5]=((-0.0164003806106752)+(((0.84)*x1066*x1071))+(((-1.0)*sj0*sj2*x1073))+((cj2*x1073*x1077))+(((0.0003664416)*x1066))+(((0.00087248)*sj2*x1072))+(((-1.0)*pp))+(((0.84)*px*x1075))+(((-0.00087248)*pz*x1078))+(((-0.00087248)*x1071))+(((-1.0)*cj0*x1073))+(((0.84)*pz*x1065))+(((3.806106752e-7)*x1079))+(((0.00087248)*py*x1065*x1069)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1081=cj2*cj2;
IkReal x1082=cj3*cj3;
IkReal x1083=(py*sj0);
IkReal x1084=(cj0*px);
IkReal x1085=((0.4)*cj3);
IkReal x1086=((0.00043624)*cj2);
IkReal x1087=((0.4)*cj2*sj3);
IkReal x1088=((0.16)*x1082);
CheckValue<IkReal> x1089=IKPowWithIntegerCheck(IKsign(((-0.1764)+((x1081*x1088))+(((-0.336)*cj3))+(((0.000348992)*sj3*x1081))+(((-0.160000190305338)*x1081))+(((-1.0)*x1088)))),-1);
if(!x1089.valid){
continue;
}
CheckValue<IkReal> x1090 = IKatan2WithCheck(IkReal(((-0.0001832208)+(((-1.0)*pz*x1087))+((pz*x1086))+(((-0.000174496)*cj3))+(((-1.0)*x1084*x1085))+(((-1.0)*x1083*x1085))+(((-0.42)*x1083))+(((-0.42)*x1084)))),IkReal(((((-1.0)*pz*x1085))+(((-1.903053376e-7)*cj2))+(((0.000174496)*cj2*sj3))+(((-1.0)*x1084*x1086))+(((-1.0)*x1083*x1086))+(((-0.42)*pz))+((x1084*x1087))+((x1083*x1087)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1090.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1089.value)))+(x1090.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1091=IKcos(j1);
IkReal x1092=IKsin(j1);
IkReal x1093=((0.4)*cj3);
IkReal x1094=((1.0)*px);
IkReal x1095=(cj2*sj0);
IkReal x1096=((0.4)*sj3);
IkReal x1097=(py*sj0);
IkReal x1098=(cj0*py);
IkReal x1099=((0.00087248)*px);
IkReal x1100=(px*sj0*sj2);
IkReal x1101=(cj0*x1092);
IkReal x1102=((1.0)*x1091);
IkReal x1103=(cj0*x1091);
IkReal x1104=(cj2*x1092);
IkReal x1105=(cj2*x1091);
IkReal x1106=((0.00043624)*x1105);
evalcond[0]=((((-1.0)*x1091*x1093))+(((0.00043624)*x1104))+pz+(((-0.42)*x1091))+(((-1.0)*x1096*x1104)));
evalcond[1]=((0.42)+x1093+(((-0.00043624)*x1092))+(((-1.0)*x1092*x1097))+(((-1.0)*pz*x1102))+(((-1.0)*x1094*x1101)));
evalcond[2]=((-0.00043624)+x1106+(((-1.0)*x1097))+(((0.42)*x1092))+((x1092*x1093))+(((-1.0)*cj0*x1094))+(((-1.0)*x1096*x1105)));
evalcond[3]=((((-1.0)*sj2*x1097*x1102))+((pz*sj2*x1092))+(((-0.00043624)*sj2*x1091))+(((-1.0)*x1094*x1095))+((cj2*x1098))+(((-1.0)*sj2*x1094*x1103)));
evalcond[4]=((0.00043624)+(((-1.0)*py*x1095*x1102))+x1100+(((-1.0)*x1096))+(((-1.0)*cj2*x1094*x1103))+(((-1.0)*sj2*x1098))+((pz*x1104))+(((-1.0)*x1106)));
evalcond[5]=((-0.0164003806106752)+(((-1.0)*sj0*sj2*x1099))+(((0.84)*x1092*x1097))+(((-0.00087248)*x1097))+(((3.806106752e-7)*x1105))+(((-0.00087248)*pz*x1104))+(((0.00087248)*py*x1091*x1095))+(((0.00087248)*sj2*x1098))+(((0.84)*px*x1101))+(((-1.0)*pp))+(((0.84)*pz*x1091))+((cj2*x1099*x1103))+(((0.0003664416)*x1092))+(((-1.0)*cj0*x1099)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1107=(py*sj0);
IkReal x1108=(cj0*px);
IkReal x1109=(cj2*pz);
IkReal x1110=((1.0)*pz);
IkReal x1111=((0.4)*cj3);
IkReal x1112=((0.000174496)*cj3);
IkReal x1113=(cj2*sj3);
CheckValue<IkReal> x1114=IKPowWithIntegerCheck(IKsign(((-0.0001832208)+(((-0.42)*x1107))+(((-0.42)*x1108))+(((0.4)*sj3*x1109))+(((-1.0)*x1107*x1111))+(((-1.0)*x1108*x1111))+(((-0.00043624)*x1109))+(((-1.0)*x1112)))),-1);
if(!x1114.valid){
continue;
}
CheckValue<IkReal> x1115 = IKatan2WithCheck(IkReal(((-0.1764)+(((-0.336)*cj3))+(pz*pz)+(((-0.16)*(cj3*cj3))))),IkReal(((((0.168)*x1113))+(((-0.00043624)*pz))+(((-1.0)*x1107*x1110))+(((-1.0)*x1108*x1110))+(((0.16)*cj3*x1113))+(((-0.0001832208)*cj2))+(((-1.0)*cj2*x1112)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1115.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1114.value)))+(x1115.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1116=IKcos(j1);
IkReal x1117=IKsin(j1);
IkReal x1118=((0.4)*cj3);
IkReal x1119=((1.0)*px);
IkReal x1120=(cj2*sj0);
IkReal x1121=((0.4)*sj3);
IkReal x1122=(py*sj0);
IkReal x1123=(cj0*py);
IkReal x1124=((0.00087248)*px);
IkReal x1125=(px*sj0*sj2);
IkReal x1126=(cj0*x1117);
IkReal x1127=((1.0)*x1116);
IkReal x1128=(cj0*x1116);
IkReal x1129=(cj2*x1117);
IkReal x1130=(cj2*x1116);
IkReal x1131=((0.00043624)*x1130);
evalcond[0]=((((-0.42)*x1116))+(((-1.0)*x1116*x1118))+(((-1.0)*x1121*x1129))+pz+(((0.00043624)*x1129)));
evalcond[1]=((0.42)+x1118+(((-1.0)*pz*x1127))+(((-1.0)*x1117*x1122))+(((-1.0)*x1119*x1126))+(((-0.00043624)*x1117)));
evalcond[2]=((-0.00043624)+x1131+(((0.42)*x1117))+(((-1.0)*x1121*x1130))+(((-1.0)*x1122))+((x1117*x1118))+(((-1.0)*cj0*x1119)));
evalcond[3]=(((cj2*x1123))+(((-1.0)*sj2*x1122*x1127))+(((-1.0)*sj2*x1119*x1128))+(((-1.0)*x1119*x1120))+((pz*sj2*x1117))+(((-0.00043624)*sj2*x1116)));
evalcond[4]=((0.00043624)+x1125+((pz*x1129))+(((-1.0)*py*x1120*x1127))+(((-1.0)*cj2*x1119*x1128))+(((-1.0)*x1131))+(((-1.0)*sj2*x1123))+(((-1.0)*x1121)));
evalcond[5]=((-0.0164003806106752)+(((-0.00087248)*pz*x1129))+(((0.84)*pz*x1116))+(((0.84)*px*x1126))+((cj2*x1124*x1128))+(((-0.00087248)*x1122))+(((-1.0)*pp))+(((0.0003664416)*x1117))+(((0.00087248)*py*x1116*x1120))+(((0.84)*x1117*x1122))+(((-1.0)*sj0*sj2*x1124))+(((0.00087248)*sj2*x1123))+(((3.806106752e-7)*x1130))+(((-1.0)*cj0*x1124)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1132=cj0*cj0;
IkReal x1133=py*py;
IkReal x1134=px*px;
IkReal x1135=(py*sj2);
IkReal x1136=(pz*sj2);
IkReal x1137=(pp*sj2);
IkReal x1138=((0.84)*sj2);
IkReal x1139=((1.0)*pp);
IkReal x1140=(py*pz);
IkReal x1141=(px*sj0);
IkReal x1142=((0.84)*cj2);
IkReal x1143=((0.00087248)*cj0);
IkReal x1144=((0.00087248)*sj2);
IkReal x1145=(cj0*py);
IkReal x1146=((0.0003664416)*cj2);
IkReal x1147=(px*py);
IkReal x1148=((0.00087248)*pz*sj0);
IkReal x1149=(cj0*x1142);
IkReal x1150=(sj0*x1134);
IkReal x1151=(sj0*x1133);
IkReal x1152=(cj0*px*sj2);
IkReal x1153=(x1132*x1147);
IkReal x1154=(x1132*x1133);
IkReal x1155=(x1132*x1134);
CheckValue<IkReal> x1156 = IKatan2WithCheck(IkReal(((((-1.0)*x1144*x1155))+((x1140*x1149))+(((0.00174496)*x1153))+(((3.806106752e-7)*x1145))+(((-0.0164007612213504)*x1152))+(((-3.806106752e-7)*x1141))+((x1143*x1151))+(((-1.0)*x1143*x1150))+(((-1.0)*pz*x1141*x1142))+(((-1.0)*cj0*px*x1137))+(((-0.00174496)*cj0*x1135*x1141))+(((-0.00087248)*x1147))+(((-0.0164007612213504)*sj0*x1135))+(((-1.0)*x1133*x1144))+(((-7.15450203760095e-6)*sj2))+(((-1.0)*sj0*x1135*x1139))+((x1144*x1154))+(((-0.00043624)*x1137)))),IkReal(((((-1.68)*cj2*x1153))+(((-1.0)*x1135*x1148))+(((-1.0)*x1145*x1146))+((x1140*x1143))+((x1149*x1150))+(((-1.0)*x1149*x1151))+((x1141*x1146))+((x1142*x1147))+(((-0.00087248)*pz*x1141))+(((-1.0)*x1136*x1139))+(((-0.0164003806106752)*x1136))+(((-1.0)*px*x1136*x1143)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1156.valid){
continue;
}
CheckValue<IkReal> x1157=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1138*x1155))+(((-0.0007328832)*sj0*x1135))+(((-0.84)*pz*x1136))+(((-1.59856483584e-7)*sj2))+(((-0.0007328832)*x1152))+((x1138*x1154))+(((-1.68)*cj0*x1135*x1141))+(((-1.0)*x1133*x1138)))),-1);
if(!x1157.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1156.value)+(((1.5707963267949)*(x1157.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[2];
IkReal x1158=IKcos(j1);
IkReal x1159=IKsin(j1);
IkReal x1160=((0.00087248)*py);
IkReal x1161=(cj0*sj2);
IkReal x1162=(cj0*px);
IkReal x1163=(px*sj0);
IkReal x1164=(py*sj0);
IkReal x1165=(cj2*x1158);
IkReal x1166=(pz*x1159);
IkReal x1167=((0.84)*x1159);
IkReal x1168=((1.0)*x1158);
evalcond[0]=(((sj2*x1166))+(((-0.00043624)*sj2*x1158))+(((-1.0)*px*x1161*x1168))+(((-1.0)*sj2*x1164*x1168))+((cj0*cj2*py))+(((-1.0)*cj2*x1163)));
evalcond[1]=((-0.0164003806106752)+(((-0.00087248)*cj2*x1166))+((sj0*x1160*x1165))+((x1164*x1167))+(((0.00087248)*x1162*x1165))+(((-0.00087248)*sj2*x1163))+(((-0.00087248)*x1162))+((x1162*x1167))+(((0.0003664416)*x1159))+(((-1.0)*sj0*x1160))+(((-1.0)*pp))+(((0.84)*pz*x1158))+(((3.806106752e-7)*x1165))+((x1160*x1161)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[1];
j3eval[0]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
j3eval[0]=(cj1+(((962.772785622593)*cj2*sj1)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=sj2;
j3eval[1]=cj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1169=((2.5)*pz);
IkReal x1170=((2.5)*cj0*px);
IkReal x1171=((2.5)*py*sj0);
if( IKabs(((0.0010906)+(((-0.0010906)*cj1))+((sj1*x1169))+(((-1.0)*cj1*x1170))+(((-1.0)*cj1*x1171)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.05)+((cj1*x1169))+(((0.0010906)*sj1))+((sj1*x1170))+((sj1*x1171)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0010906)+(((-0.0010906)*cj1))+((sj1*x1169))+(((-1.0)*cj1*x1170))+(((-1.0)*cj1*x1171))))+IKsqr(((-1.05)+((cj1*x1169))+(((0.0010906)*sj1))+((sj1*x1170))+((sj1*x1171))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.0010906)+(((-0.0010906)*cj1))+((sj1*x1169))+(((-1.0)*cj1*x1170))+(((-1.0)*cj1*x1171))), ((-1.05)+((cj1*x1169))+(((0.0010906)*sj1))+((sj1*x1170))+((sj1*x1171))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1172=IKcos(j3);
IkReal x1173=IKsin(j3);
IkReal x1174=((0.00043624)*sj1);
IkReal x1175=((0.00043624)*cj1);
IkReal x1176=(py*sj0);
IkReal x1177=((1.0)*cj1);
IkReal x1178=(cj0*px);
IkReal x1179=((1.0)*sj1);
IkReal x1180=((0.4)*x1172);
IkReal x1181=((0.4)*x1173);
evalcond[0]=((((-1.0)*sj1*x1181))+x1174+(((-1.0)*cj1*x1180))+pz+(((-0.42)*cj1)));
evalcond[1]=((0.3364)+(((-0.00087248)*x1178))+(((-0.00087248)*x1176))+(((-0.000348992)*x1173))+(((-1.0)*pp))+(((0.336)*x1172)));
evalcond[2]=((0.00043624)+(((-1.0)*x1181))+(((-1.0)*x1176*x1177))+((pz*sj1))+(((-1.0)*x1175))+(((-1.0)*x1177*x1178)));
evalcond[3]=((0.42)+x1180+(((-1.0)*x1178*x1179))+(((-1.0)*pz*x1177))+(((-1.0)*x1176*x1179))+(((-1.0)*x1174)));
evalcond[4]=((-0.00043624)+x1175+(((0.42)*sj1))+((sj1*x1180))+(((-1.0)*cj1*x1181))+(((-1.0)*x1176))+(((-1.0)*x1178)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1182=((0.00259666666666667)*cj1);
IkReal x1183=(py*sj0);
IkReal x1184=(cj0*px);
IkReal x1185=((2.5)*cj1);
IkReal x1186=(pz*sj1);
if( IKabs(((0.0010906)+((x1184*x1185))+((x1183*x1185))+(((-2.5)*x1186))+(((0.0010906)*cj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00118934342061)+(((2.97619047619048)*pp))+(((-0.00259666666666667)*x1186))+((x1182*x1183))+((x1182*x1184))+(((1.13276986666667e-6)*cj1))+(((0.00259666666666667)*x1184))+(((0.00259666666666667)*x1183)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0010906)+((x1184*x1185))+((x1183*x1185))+(((-2.5)*x1186))+(((0.0010906)*cj1))))+IKsqr(((-1.00118934342061)+(((2.97619047619048)*pp))+(((-0.00259666666666667)*x1186))+((x1182*x1183))+((x1182*x1184))+(((1.13276986666667e-6)*cj1))+(((0.00259666666666667)*x1184))+(((0.00259666666666667)*x1183))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.0010906)+((x1184*x1185))+((x1183*x1185))+(((-2.5)*x1186))+(((0.0010906)*cj1))), ((-1.00118934342061)+(((2.97619047619048)*pp))+(((-0.00259666666666667)*x1186))+((x1182*x1183))+((x1182*x1184))+(((1.13276986666667e-6)*cj1))+(((0.00259666666666667)*x1184))+(((0.00259666666666667)*x1183))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1187=IKsin(j3);
IkReal x1188=IKcos(j3);
IkReal x1189=((0.00043624)*sj1);
IkReal x1190=((0.00043624)*cj1);
IkReal x1191=(py*sj0);
IkReal x1192=((1.0)*pz);
IkReal x1193=(cj0*px);
IkReal x1194=((1.0)*sj1);
IkReal x1195=((0.4)*x1188);
IkReal x1196=((0.4)*x1187);
evalcond[0]=(((sj1*x1196))+(((-1.0)*x1189))+pz+(((-1.0)*cj1*x1195))+(((-0.42)*cj1)));
evalcond[1]=((0.00043624)+x1190+(((-1.0)*x1196))+((cj1*x1191))+((cj1*x1193))+(((-1.0)*sj1*x1192)));
evalcond[2]=((0.3364)+(((-0.000348992)*x1187))+(((-0.00087248)*x1193))+(((-0.00087248)*x1191))+(((-1.0)*pp))+(((0.336)*x1188)));
evalcond[3]=((0.42)+x1195+(((-1.0)*x1193*x1194))+(((-1.0)*x1191*x1194))+(((-1.0)*x1189))+(((-1.0)*cj1*x1192)));
evalcond[4]=((-0.00043624)+(((0.42)*sj1))+(((-1.0)*x1190))+((sj1*x1195))+(((-1.0)*x1191))+(((-1.0)*x1193))+((cj1*x1196)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1197=((2.5)*sj0);
IkReal x1198=((2.5)*cj0);
if( IKabs(((0.0010906)+(((-1.0)*py*sj2*x1198))+(((2.5)*cj2*pz))+((px*sj2*x1197)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0489094)+((py*x1197))+((px*x1198)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0010906)+(((-1.0)*py*sj2*x1198))+(((2.5)*cj2*pz))+((px*sj2*x1197))))+IKsqr(((-1.0489094)+((py*x1197))+((px*x1198))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.0010906)+(((-1.0)*py*sj2*x1198))+(((2.5)*cj2*pz))+((px*sj2*x1197))), ((-1.0489094)+((py*x1197))+((px*x1198))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1199=IKsin(j3);
IkReal x1200=IKcos(j3);
IkReal x1201=(px*sj0);
IkReal x1202=((1.0)*cj0);
IkReal x1203=(py*sj0);
IkReal x1204=((0.4)*x1199);
evalcond[0]=((((-1.0)*cj2*x1204))+pz+(((0.00043624)*cj2)));
evalcond[1]=((0.41956376)+(((0.4)*x1200))+(((-1.0)*x1203))+(((-1.0)*px*x1202)));
evalcond[2]=(x1201+(((0.00043624)*sj2))+(((-1.0)*sj2*x1204))+(((-1.0)*py*x1202)));
evalcond[3]=((0.00043624)+((sj2*x1201))+((cj2*pz))+(((-1.0)*x1204))+(((-1.0)*py*sj2*x1202)));
evalcond[4]=((0.3364)+(((0.336)*x1200))+(((-0.000348992)*x1199))+(((-1.0)*pp))+(((-0.00087248)*x1203))+(((-0.00087248)*cj0*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1205=((2.5)*sj0);
IkReal x1206=((2.5)*cj0);
if( IKabs(((0.0010906)+(((-2.5)*cj2*pz))+((px*sj2*x1205))+(((-1.0)*py*sj2*x1206)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0510906)+(((-1.0)*px*x1206))+(((-1.0)*py*x1205)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0010906)+(((-2.5)*cj2*pz))+((px*sj2*x1205))+(((-1.0)*py*sj2*x1206))))+IKsqr(((-1.0510906)+(((-1.0)*px*x1206))+(((-1.0)*py*x1205))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.0010906)+(((-2.5)*cj2*pz))+((px*sj2*x1205))+(((-1.0)*py*sj2*x1206))), ((-1.0510906)+(((-1.0)*px*x1206))+(((-1.0)*py*x1205))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1207=IKsin(j3);
IkReal x1208=IKcos(j3);
IkReal x1209=(cj0*px);
IkReal x1210=(px*sj0);
IkReal x1211=(py*sj0);
IkReal x1212=((1.0)*cj0*py);
IkReal x1213=((0.4)*x1207);
evalcond[0]=((((-0.00043624)*cj2))+pz+((cj2*x1213)));
evalcond[1]=((0.42043624)+(((0.4)*x1208))+x1209+x1211);
evalcond[2]=(x1210+(((0.00043624)*sj2))+(((-1.0)*sj2*x1213))+(((-1.0)*x1212)));
evalcond[3]=((0.00043624)+(((-1.0)*cj2*pz))+((sj2*x1210))+(((-1.0)*sj2*x1212))+(((-1.0)*x1213)));
evalcond[4]=((0.3364)+(((-0.000348992)*x1207))+(((0.336)*x1208))+(((-1.0)*pp))+(((-0.00087248)*x1209))+(((-0.00087248)*x1211)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x1219=IKPowWithIntegerCheck(sj2,-1);
if(!x1219.valid){
continue;
}
IkReal x1214=x1219.value;
IkReal x1215=((0.5)*x1214);
IkReal x1216=(cj2*sj1);
IkReal x1217=((5.0)*px*sj0);
IkReal x1218=((5.0)*cj0*py);
CheckValue<IkReal> x1220=IKPowWithIntegerCheck(cj1,-1);
if(!x1220.valid){
continue;
}
if( IKabs((x1215*((x1217+(((0.0021812)*sj2))+(((-1.0)*x1218)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1215*(x1220.value)*(((((5.0)*pz*sj2))+(((-1.0)*x1216*x1217))+(((-2.1)*cj1*sj2))+((x1216*x1218)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1215*((x1217+(((0.0021812)*sj2))+(((-1.0)*x1218))))))+IKsqr((x1215*(x1220.value)*(((((5.0)*pz*sj2))+(((-1.0)*x1216*x1217))+(((-2.1)*cj1*sj2))+((x1216*x1218))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x1215*((x1217+(((0.0021812)*sj2))+(((-1.0)*x1218))))), (x1215*(x1220.value)*(((((5.0)*pz*sj2))+(((-1.0)*x1216*x1217))+(((-2.1)*cj1*sj2))+((x1216*x1218))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x1221=IKsin(j3);
IkReal x1222=IKcos(j3);
IkReal x1223=(px*sj0);
IkReal x1224=((0.4)*cj1);
IkReal x1225=(py*sj0);
IkReal x1226=((0.4)*sj1);
IkReal x1227=((1.0)*cj1);
IkReal x1228=((0.00043624)*cj2);
IkReal x1229=(cj0*px);
IkReal x1230=((1.0)*sj1);
IkReal x1231=(cj1*x1228);
IkReal x1232=(cj2*x1221);
IkReal x1233=((0.4)*x1221);
IkReal x1234=((1.0)*cj0*py);
evalcond[0]=(x1223+(((-1.0)*x1234))+(((0.00043624)*sj2))+(((-1.0)*sj2*x1233)));
evalcond[1]=(((sj1*x1228))+(((-1.0)*x1226*x1232))+(((-1.0)*x1222*x1224))+pz+(((-0.42)*cj1)));
evalcond[2]=((0.3364)+(((-0.00087248)*x1229))+(((-0.00087248)*x1225))+(((0.336)*x1222))+(((-1.0)*pp))+(((-0.000348992)*x1221)));
evalcond[3]=((0.42)+(((-1.0)*x1225*x1230))+(((-1.0)*pz*x1227))+(((-0.00043624)*sj1))+(((0.4)*x1222))+(((-1.0)*x1229*x1230)));
evalcond[4]=((-0.00043624)+x1231+(((-1.0)*x1229))+(((-1.0)*x1225))+(((-1.0)*x1224*x1232))+(((0.42)*sj1))+((x1222*x1226)));
evalcond[5]=((0.00043624)+((sj2*x1223))+(((-1.0)*x1233))+(((-1.0)*x1231))+((cj2*pz*sj1))+(((-1.0)*sj2*x1234))+(((-1.0)*cj2*x1225*x1227))+(((-1.0)*cj2*x1227*x1229)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1235=(cj2*sj1);
IkReal x1236=((13632.5)*cj1);
IkReal x1237=(cj0*px);
IkReal x1238=(py*sj0);
CheckValue<IkReal> x1239=IKPowWithIntegerCheck(((((5453.0)*cj1))+(((5250000.0)*x1235))),-1);
if(!x1239.valid){
continue;
}
CheckValue<IkReal> x1240=IKPowWithIntegerCheck(((((10500000.0)*x1235))+(((10906.0)*cj1))),-1);
if(!x1240.valid){
continue;
}
if( IKabs(((x1239.value)*(((((-256250.0)*cj1))+(((5725.65)*x1235))+(((13125000.0)*pz))+(((-1.0)*x1236*x1237))+(((-1.0)*x1236*x1238))+(((-15625000.0)*cj1*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1240.value)*(((((27265.0)*x1235*x1237))+(((27265.0)*x1235*x1238))+(((-10512488.1059164)*x1235))+(((-11451.3)*cj1))+(((31250000.0)*pp*x1235))+(((27265.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1239.value)*(((((-256250.0)*cj1))+(((5725.65)*x1235))+(((13125000.0)*pz))+(((-1.0)*x1236*x1237))+(((-1.0)*x1236*x1238))+(((-15625000.0)*cj1*pp))))))+IKsqr(((x1240.value)*(((((27265.0)*x1235*x1237))+(((27265.0)*x1235*x1238))+(((-10512488.1059164)*x1235))+(((-11451.3)*cj1))+(((31250000.0)*pp*x1235))+(((27265.0)*pz))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((x1239.value)*(((((-256250.0)*cj1))+(((5725.65)*x1235))+(((13125000.0)*pz))+(((-1.0)*x1236*x1237))+(((-1.0)*x1236*x1238))+(((-15625000.0)*cj1*pp))))), ((x1240.value)*(((((27265.0)*x1235*x1237))+(((27265.0)*x1235*x1238))+(((-10512488.1059164)*x1235))+(((-11451.3)*cj1))+(((31250000.0)*pp*x1235))+(((27265.0)*pz))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x1241=IKsin(j3);
IkReal x1242=IKcos(j3);
IkReal x1243=(px*sj0);
IkReal x1244=((0.4)*cj1);
IkReal x1245=(py*sj0);
IkReal x1246=((0.4)*sj1);
IkReal x1247=((1.0)*cj1);
IkReal x1248=((0.00043624)*cj2);
IkReal x1249=(cj0*px);
IkReal x1250=((1.0)*sj1);
IkReal x1251=(cj1*x1248);
IkReal x1252=(cj2*x1241);
IkReal x1253=((0.4)*x1241);
IkReal x1254=((1.0)*cj0*py);
evalcond[0]=((((-1.0)*x1254))+x1243+(((0.00043624)*sj2))+(((-1.0)*sj2*x1253)));
evalcond[1]=((((-1.0)*x1246*x1252))+(((-1.0)*x1242*x1244))+pz+(((-0.42)*cj1))+((sj1*x1248)));
evalcond[2]=((0.3364)+(((-0.000348992)*x1241))+(((0.336)*x1242))+(((-1.0)*pp))+(((-0.00087248)*x1249))+(((-0.00087248)*x1245)));
evalcond[3]=((0.42)+(((-1.0)*x1249*x1250))+(((-1.0)*pz*x1247))+(((0.4)*x1242))+(((-1.0)*x1245*x1250))+(((-0.00043624)*sj1)));
evalcond[4]=((-0.00043624)+x1251+(((0.42)*sj1))+(((-1.0)*x1249))+(((-1.0)*x1245))+(((-1.0)*x1244*x1252))+((x1242*x1246)));
evalcond[5]=((0.00043624)+(((-1.0)*x1253))+(((-1.0)*x1251))+(((-1.0)*cj2*x1247*x1249))+((sj2*x1243))+(((-1.0)*sj2*x1254))+((cj2*pz*sj1))+(((-1.0)*cj2*x1245*x1247)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1255=((2.5)*sj1);
CheckValue<IkReal> x1256=IKPowWithIntegerCheck(sj2,-1);
if(!x1256.valid){
continue;
}
if( IKabs(((0.5)*(x1256.value)*(((((0.0021812)*sj2))+(((5.0)*px*sj0))+(((-5.0)*cj0*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.05)+(((0.0010906)*sj1))+((cj0*px*x1255))+(((2.5)*cj1*pz))+((py*sj0*x1255)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.5)*(x1256.value)*(((((0.0021812)*sj2))+(((5.0)*px*sj0))+(((-5.0)*cj0*py))))))+IKsqr(((-1.05)+(((0.0010906)*sj1))+((cj0*px*x1255))+(((2.5)*cj1*pz))+((py*sj0*x1255))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.5)*(x1256.value)*(((((0.0021812)*sj2))+(((5.0)*px*sj0))+(((-5.0)*cj0*py))))), ((-1.05)+(((0.0010906)*sj1))+((cj0*px*x1255))+(((2.5)*cj1*pz))+((py*sj0*x1255))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x1257=IKsin(j3);
IkReal x1258=IKcos(j3);
IkReal x1259=(px*sj0);
IkReal x1260=((0.4)*cj1);
IkReal x1261=(py*sj0);
IkReal x1262=((0.4)*sj1);
IkReal x1263=((1.0)*cj1);
IkReal x1264=((0.00043624)*cj2);
IkReal x1265=(cj0*px);
IkReal x1266=((1.0)*sj1);
IkReal x1267=(cj1*x1264);
IkReal x1268=(cj2*x1257);
IkReal x1269=((0.4)*x1257);
IkReal x1270=((1.0)*cj0*py);
evalcond[0]=(x1259+(((-1.0)*x1270))+(((0.00043624)*sj2))+(((-1.0)*sj2*x1269)));
evalcond[1]=((((-1.0)*x1258*x1260))+((sj1*x1264))+(((-1.0)*x1262*x1268))+pz+(((-0.42)*cj1)));
evalcond[2]=((0.3364)+(((-0.00087248)*x1265))+(((-0.00087248)*x1261))+(((-1.0)*pp))+(((0.336)*x1258))+(((-0.000348992)*x1257)));
evalcond[3]=((0.42)+(((-1.0)*x1261*x1266))+(((-0.00043624)*sj1))+(((-1.0)*x1265*x1266))+(((-1.0)*pz*x1263))+(((0.4)*x1258)));
evalcond[4]=((-0.00043624)+x1267+(((-1.0)*x1260*x1268))+((x1258*x1262))+(((0.42)*sj1))+(((-1.0)*x1265))+(((-1.0)*x1261)));
evalcond[5]=((0.00043624)+(((-1.0)*sj2*x1270))+((cj2*pz*sj1))+(((-1.0)*cj2*x1263*x1265))+(((-1.0)*cj2*x1261*x1263))+(((-1.0)*x1269))+(((-1.0)*x1267))+((sj2*x1259)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x222=((1.0)*cj3);
IkReal x223=(sj0*sj2);
IkReal x224=(cj2*sj1);
IkReal x225=(cj1*cj3);
IkReal x226=(cj0*sj2);
IkReal x227=(sj1*sj2);
IkReal x228=(cj1*sj3);
IkReal x229=((1.0)*cj2);
IkReal x230=((1.0)*cj1);
IkReal x231=(sj3*x226);
IkReal x232=(((cj2*x225))+((sj1*sj3)));
IkReal x233=((((-1.0)*x222*x224))+x228);
IkReal x234=(((cj0*cj2))+(((-1.0)*x223*x230)));
IkReal x235=((((-1.0)*x228*x229))+((cj3*sj1)));
IkReal x236=(x225+((sj3*x224)));
IkReal x237=(sj0*x235);
IkReal x238=((((-1.0)*sj0*x229))+(((-1.0)*x226*x230)));
IkReal x239=(((cj3*x226))+((sj0*x232)));
IkReal x240=((((-1.0)*x222*x223))+((cj0*x232)));
IkReal x241=(((sj3*x223))+((cj0*x235)));
IkReal x242=(x237+(((-1.0)*x231)));
new_r00=(((r10*x239))+((r20*x233))+((r00*x240)));
new_r01=(((r11*x239))+((r01*x240))+((r21*x233)));
new_r02=(((r02*x240))+((r12*x239))+((r22*x233)));
new_r10=(((r20*x227))+((r10*x234))+((r00*x238)));
new_r11=(((r11*x234))+((r01*x238))+((r21*x227)));
new_r12=(((r02*x238))+((r22*x227))+((r12*x234)));
new_r20=(((r20*x236))+((r00*x241))+((r10*x242)));
new_r21=(((r11*((x237+(((-1.0)*x231))))))+((r01*x241))+((r21*x236)));
new_r22=(((r02*x241))+((r12*x242))+((r22*x236)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=new_r12;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x243=new_r22*new_r22;
IkReal x244=((16.0)*new_r10);
IkReal x245=((16.0)*new_r01);
IkReal x246=((16.0)*new_r22);
IkReal x247=((8.0)*new_r11);
IkReal x248=((8.0)*new_r00);
IkReal x249=(x243*x244);
IkReal x250=(x243*x245);
j4eval[0]=((IKabs((x250+(((-1.0)*x245)))))+(IKabs((x249+(((-1.0)*x244)))))+(IKabs((x244+(((-1.0)*x249)))))+(IKabs((x245+(((-1.0)*x250)))))+(IKabs((((new_r22*x247))+(((-1.0)*x248)))))+(IKabs(((((-32.0)*new_r00*x243))+(((16.0)*new_r00))+((new_r11*x246)))))+(IKabs(((((-1.0)*new_r22*x248))+((x243*x247)))))+(IKabs(((((32.0)*new_r11))+(((-1.0)*new_r00*x246))+(((-16.0)*new_r11*x243))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j6]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j4evalpoly[1];
IkReal x251=new_r22*new_r22;
IkReal x252=((16.0)*new_r10);
IkReal x253=(new_r11*new_r22);
IkReal x254=(x251*x252);
IkReal x255=((((8.0)*x253))+(((-8.0)*new_r00)));
op[0]=x255;
op[1]=(x252+(((-1.0)*x254)));
op[2]=((((16.0)*new_r00))+(((16.0)*x253))+(((-32.0)*new_r00*x251)));
op[3]=(x254+(((-1.0)*x252)));
op[4]=x255;
polyroots4(op,zeror,numroots);
IkReal j4array[4], cj4array[4], sj4array[4], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[4]={true,true,true,true};
_nj4 = 4;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x256=new_r22*new_r22;
IkReal x257=((16.0)*new_r01);
IkReal x258=(new_r00*new_r22);
IkReal x259=((8.0)*x258);
IkReal x260=(new_r11*x256);
IkReal x261=(x256*x257);
IkReal x262=((8.0)*x260);
j4evalpoly[0]=((((htj4*htj4*htj4)*((x261+(((-1.0)*x257))))))+(((htj4*htj4*htj4*htj4)*((x262+(((-1.0)*x259))))))+x262+((htj4*((x257+(((-1.0)*x261))))))+(((htj4*htj4)*(((((32.0)*new_r11))+(((-16.0)*x260))+(((-16.0)*x258))))))+(((-1.0)*x259)));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j6eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x263=cj4*cj4;
IkReal x264=(cj4*new_r22);
IkReal x265=((-1.0)+(((-1.0)*x263*(new_r22*new_r22)))+x263);
j6eval[0]=x265;
j6eval[1]=((IKabs((((new_r00*sj4))+((new_r01*x264)))))+(IKabs((((new_r01*sj4))+(((-1.0)*new_r00*x264))))));
j6eval[2]=IKsign(x265);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j6eval[0]=new_r22;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x266=new_r22*new_r22;
j6eval[0]=(((cj4*x266))+(((-1.0)*cj4)));
j6eval[1]=((((-1.0)*sj4))+((sj4*x266)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x267=IKsin(j6);
IkReal x268=IKcos(j6);
evalcond[0]=x267;
evalcond[1]=((-1.0)*x268);
evalcond[2]=((((-1.0)*x267))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x268))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x269=IKsin(j6);
IkReal x270=IKcos(j6);
evalcond[0]=x269;
evalcond[1]=((-1.0)*x270);
evalcond[2]=((((-1.0)*x269))+new_r00);
evalcond[3]=((((-1.0)*x270))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x271=IKsin(j6);
IkReal x272=IKcos(j6);
evalcond[0]=x271;
evalcond[1]=((-1.0)*x272);
evalcond[2]=((((-1.0)*x271))+new_r10);
evalcond[3]=((((-1.0)*x272))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x273=IKsin(j6);
IkReal x274=IKcos(j6);
evalcond[0]=x273;
evalcond[1]=((-1.0)*x274);
evalcond[2]=((((-1.0)*x273))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x274))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x275=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x275.valid){
continue;
}
if((x275.value) < -0.00001)
continue;
IkReal gconst40=((-1.0)*(IKsqrt(x275.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj4)))))+(IKabs(((((-1.0)*gconst40))+cj4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40)))));
cj4=gconst40;
if( (gconst40) < -1-IKFAST_SINCOS_THRESH || (gconst40) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst40);
CheckValue<IkReal> x276=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x276.valid){
continue;
}
if((x276.value) < -0.00001)
continue;
IkReal gconst40=((-1.0)*(IKsqrt(x276.value)));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
CheckValue<IkReal> x277=IKPowWithIntegerCheck(gconst40,-1);
if(!x277.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x277.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10))))+IKsqr((new_r11*(x277.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10))), (new_r11*(x277.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x278=IKcos(j6);
IkReal x279=IKsin(j6);
IkReal x280=((1.0)*gconst40);
if((((1.0)+(((-1.0)*gconst40*x280)))) < -0.00001)
continue;
IkReal x281=IKsqrt(((1.0)+(((-1.0)*gconst40*x280))));
IkReal x282=((1.0)*x281);
evalcond[0]=x279;
evalcond[1]=((-1.0)*x278);
evalcond[2]=(new_r11+(((-1.0)*x278*x280)));
evalcond[3]=(new_r10+(((-1.0)*x279*x280)));
evalcond[4]=(((x278*x281))+new_r01);
evalcond[5]=(((x279*x281))+new_r00);
evalcond[6]=(((gconst40*new_r10))+(((-1.0)*x279))+(((-1.0)*new_r00*x282)));
evalcond[7]=(((gconst40*new_r11))+(((-1.0)*x278))+(((-1.0)*new_r01*x282)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x283=IKPowWithIntegerCheck(IKsign(gconst40),-1);
if(!x283.valid){
continue;
}
CheckValue<IkReal> x284 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x284.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x283.value)))+(x284.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x285=IKcos(j6);
IkReal x286=IKsin(j6);
IkReal x287=((1.0)*gconst40);
if((((1.0)+(((-1.0)*gconst40*x287)))) < -0.00001)
continue;
IkReal x288=IKsqrt(((1.0)+(((-1.0)*gconst40*x287))));
IkReal x289=((1.0)*x288);
evalcond[0]=x286;
evalcond[1]=((-1.0)*x285);
evalcond[2]=((((-1.0)*x285*x287))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*x286*x287)));
evalcond[4]=(((x285*x288))+new_r01);
evalcond[5]=(((x286*x288))+new_r00);
evalcond[6]=(((gconst40*new_r10))+(((-1.0)*new_r00*x289))+(((-1.0)*x286)));
evalcond[7]=(((gconst40*new_r11))+(((-1.0)*x285))+(((-1.0)*new_r01*x289)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x290=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x290.valid){
continue;
}
if((x290.value) < -0.00001)
continue;
IkReal gconst40=((-1.0)*(IKsqrt(x290.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst40))+cj4)))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40)))))));
cj4=gconst40;
if( (gconst40) < -1-IKFAST_SINCOS_THRESH || (gconst40) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst40)));
CheckValue<IkReal> x291=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x291.valid){
continue;
}
if((x291.value) < -0.00001)
continue;
IkReal gconst40=((-1.0)*(IKsqrt(x291.value)));
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
CheckValue<IkReal> x292=IKPowWithIntegerCheck(gconst40,-1);
if(!x292.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x292.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10))))+IKsqr((new_r11*(x292.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40))))))))+((gconst40*new_r10))), (new_r11*(x292.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x293=IKcos(j6);
IkReal x294=IKsin(j6);
IkReal x295=((1.0)*x294);
IkReal x296=((1.0)*x293);
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
IkReal x297=IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40)))));
evalcond[0]=x294;
evalcond[1]=((-1.0)*x293);
evalcond[2]=((((-1.0)*gconst40*x296))+new_r11);
evalcond[3]=((((-1.0)*gconst40*x295))+new_r10);
evalcond[4]=((((-1.0)*x296*x297))+new_r01);
evalcond[5]=((((-1.0)*x295*x297))+new_r00);
evalcond[6]=(((gconst40*new_r10))+(((-1.0)*x295))+((new_r00*x297)));
evalcond[7]=(((gconst40*new_r11))+(((-1.0)*x296))+((new_r01*x297)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x298=IKPowWithIntegerCheck(IKsign(gconst40),-1);
if(!x298.valid){
continue;
}
CheckValue<IkReal> x299 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x299.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x298.value)))+(x299.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x300=IKcos(j6);
IkReal x301=IKsin(j6);
IkReal x302=((1.0)*x301);
IkReal x303=((1.0)*x300);
if((((1.0)+(((-1.0)*(gconst40*gconst40))))) < -0.00001)
continue;
IkReal x304=IKsqrt(((1.0)+(((-1.0)*(gconst40*gconst40)))));
evalcond[0]=x301;
evalcond[1]=((-1.0)*x300);
evalcond[2]=((((-1.0)*gconst40*x303))+new_r11);
evalcond[3]=((((-1.0)*gconst40*x302))+new_r10);
evalcond[4]=((((-1.0)*x303*x304))+new_r01);
evalcond[5]=((((-1.0)*x302*x304))+new_r00);
evalcond[6]=(((new_r00*x304))+((gconst40*new_r10))+(((-1.0)*x302)));
evalcond[7]=(((new_r01*x304))+((gconst40*new_r11))+(((-1.0)*x303)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x305=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x305.valid){
continue;
}
if((x305.value) < -0.00001)
continue;
IkReal gconst41=IKsqrt(x305.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst41))+cj4)))+(IKabs(((-1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst41*gconst41))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41)))));
cj4=gconst41;
if( (gconst41) < -1-IKFAST_SINCOS_THRESH || (gconst41) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst41);
CheckValue<IkReal> x306=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x306.valid){
continue;
}
if((x306.value) < -0.00001)
continue;
IkReal gconst41=IKsqrt(x306.value);
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst41*gconst41))))) < -0.00001)
continue;
CheckValue<IkReal> x307=IKPowWithIntegerCheck(gconst41,-1);
if(!x307.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))+((gconst41*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x307.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))+((gconst41*new_r10))))+IKsqr((new_r11*(x307.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))+((gconst41*new_r10))), (new_r11*(x307.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x308=IKcos(j6);
IkReal x309=IKsin(j6);
IkReal x310=((1.0)*gconst41);
if((((1.0)+(((-1.0)*gconst41*x310)))) < -0.00001)
continue;
IkReal x311=IKsqrt(((1.0)+(((-1.0)*gconst41*x310))));
IkReal x312=((1.0)*x311);
evalcond[0]=x309;
evalcond[1]=((-1.0)*x308);
evalcond[2]=((((-1.0)*x308*x310))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*x309*x310)));
evalcond[4]=(((x308*x311))+new_r01);
evalcond[5]=(((x309*x311))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x312))+((gconst41*new_r10))+(((-1.0)*x309)));
evalcond[7]=(((gconst41*new_r11))+(((-1.0)*x308))+(((-1.0)*new_r01*x312)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x313=IKPowWithIntegerCheck(IKsign(gconst41),-1);
if(!x313.valid){
continue;
}
CheckValue<IkReal> x314 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x314.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x313.value)))+(x314.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x315=IKcos(j6);
IkReal x316=IKsin(j6);
IkReal x317=((1.0)*gconst41);
if((((1.0)+(((-1.0)*gconst41*x317)))) < -0.00001)
continue;
IkReal x318=IKsqrt(((1.0)+(((-1.0)*gconst41*x317))));
IkReal x319=((1.0)*x318);
evalcond[0]=x316;
evalcond[1]=((-1.0)*x315);
evalcond[2]=((((-1.0)*x315*x317))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*x316*x317)));
evalcond[4]=(((x315*x318))+new_r01);
evalcond[5]=(new_r00+((x316*x318)));
evalcond[6]=((((-1.0)*new_r00*x319))+((gconst41*new_r10))+(((-1.0)*x316)));
evalcond[7]=(((gconst41*new_r11))+(((-1.0)*x315))+(((-1.0)*new_r01*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x320=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x320.valid){
continue;
}
if((x320.value) < -0.00001)
continue;
IkReal gconst41=IKsqrt(x320.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst41))+cj4)))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst41*gconst41))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41)))))));
cj4=gconst41;
if( (gconst41) < -1-IKFAST_SINCOS_THRESH || (gconst41) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst41)));
CheckValue<IkReal> x321=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x321.valid){
continue;
}
if((x321.value) < -0.00001)
continue;
IkReal gconst41=IKsqrt(x321.value);
j6eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst41*gconst41))))) < -0.00001)
continue;
CheckValue<IkReal> x322=IKPowWithIntegerCheck(gconst41,-1);
if(!x322.valid){
continue;
}
if( IKabs((((gconst41*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x322.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst41*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))))+IKsqr((new_r11*(x322.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((gconst41*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst41*gconst41))))))))), (new_r11*(x322.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x323=IKcos(j6);
IkReal x324=IKsin(j6);
IkReal x325=((1.0)*gconst41);
IkReal x326=((1.0)*x323);
IkReal x327=((1.0)*x324);
if((((1.0)+(((-1.0)*gconst41*x325)))) < -0.00001)
continue;
IkReal x328=IKsqrt(((1.0)+(((-1.0)*gconst41*x325))));
evalcond[0]=x324;
evalcond[1]=((-1.0)*x323);
evalcond[2]=((((-1.0)*x323*x325))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*x324*x325)));
evalcond[4]=((((-1.0)*x326*x328))+new_r01);
evalcond[5]=((((-1.0)*x327*x328))+new_r00);
evalcond[6]=(((new_r00*x328))+((gconst41*new_r10))+(((-1.0)*x327)));
evalcond[7]=(((new_r01*x328))+((gconst41*new_r11))+(((-1.0)*x326)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x329=IKPowWithIntegerCheck(IKsign(gconst41),-1);
if(!x329.valid){
continue;
}
CheckValue<IkReal> x330 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x330.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x329.value)))+(x330.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x331=IKcos(j6);
IkReal x332=IKsin(j6);
IkReal x333=((1.0)*gconst41);
IkReal x334=((1.0)*x331);
IkReal x335=((1.0)*x332);
if((((1.0)+(((-1.0)*gconst41*x333)))) < -0.00001)
continue;
IkReal x336=IKsqrt(((1.0)+(((-1.0)*gconst41*x333))));
evalcond[0]=x332;
evalcond[1]=((-1.0)*x331);
evalcond[2]=((((-1.0)*x331*x333))+new_r11);
evalcond[3]=((((-1.0)*x332*x333))+new_r10);
evalcond[4]=(new_r01+(((-1.0)*x334*x336)));
evalcond[5]=(new_r00+(((-1.0)*x335*x336)));
evalcond[6]=(((gconst41*new_r10))+((new_r00*x336))+(((-1.0)*x335)));
evalcond[7]=(((gconst41*new_r11))+((new_r01*x336))+(((-1.0)*x334)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x337=new_r22*new_r22;
CheckValue<IkReal> x338=IKPowWithIntegerCheck((((cj4*x337))+(((-1.0)*cj4))),-1);
if(!x338.valid){
continue;
}
CheckValue<IkReal> x339=IKPowWithIntegerCheck(((((-1.0)*sj4))+((sj4*x337))),-1);
if(!x339.valid){
continue;
}
if( IKabs(((x338.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x339.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x338.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x339.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((x338.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x339.value)*((((new_r10*new_r22))+new_r01))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x340=IKsin(j6);
IkReal x341=IKcos(j6);
IkReal x342=((1.0)*sj4);
IkReal x343=(cj4*new_r01);
IkReal x344=(new_r10*sj4);
IkReal x345=(new_r11*sj4);
IkReal x346=(cj4*new_r00);
IkReal x347=((1.0)*x341);
IkReal x348=(sj4*x340);
IkReal x349=(new_r22*x340);
IkReal x350=((1.0)*x340);
evalcond[0]=(x343+x345+x349);
evalcond[1]=(((new_r22*x345))+((new_r22*x343))+x340);
evalcond[2]=(((cj4*new_r10))+(((-1.0)*x350))+(((-1.0)*new_r00*x342)));
evalcond[3]=(((cj4*new_r11))+(((-1.0)*new_r01*x342))+(((-1.0)*x347)));
evalcond[4]=(((cj4*x349))+((sj4*x341))+new_r01);
evalcond[5]=(x346+x344+(((-1.0)*new_r22*x347)));
evalcond[6]=((((-1.0)*cj4*new_r22*x347))+x348+new_r00);
evalcond[7]=(((new_r22*x348))+(((-1.0)*cj4*x347))+new_r11);
evalcond[8]=(((new_r22*x344))+((new_r22*x346))+(((-1.0)*x347)));
evalcond[9]=((((-1.0)*new_r22*x341*x342))+(((-1.0)*cj4*x350))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x351=((1.0)*sj4);
CheckValue<IkReal> x352=IKPowWithIntegerCheck(new_r22,-1);
if(!x352.valid){
continue;
}
if( IKabs(((x352.value)*(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x351)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r11))+(((-1.0)*new_r01*x351)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x352.value)*(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x351))))))+IKsqr((((cj4*new_r11))+(((-1.0)*new_r01*x351))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((x352.value)*(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x351))))), (((cj4*new_r11))+(((-1.0)*new_r01*x351))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x353=IKsin(j6);
IkReal x354=IKcos(j6);
IkReal x355=((1.0)*sj4);
IkReal x356=(cj4*new_r01);
IkReal x357=(new_r10*sj4);
IkReal x358=(new_r11*sj4);
IkReal x359=(cj4*new_r00);
IkReal x360=((1.0)*x354);
IkReal x361=(sj4*x353);
IkReal x362=(new_r22*x353);
IkReal x363=((1.0)*x353);
evalcond[0]=(x356+x358+x362);
evalcond[1]=(((new_r22*x356))+((new_r22*x358))+x353);
evalcond[2]=((((-1.0)*x363))+((cj4*new_r10))+(((-1.0)*new_r00*x355)));
evalcond[3]=((((-1.0)*x360))+((cj4*new_r11))+(((-1.0)*new_r01*x355)));
evalcond[4]=(((sj4*x354))+((cj4*x362))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x360))+x357+x359);
evalcond[6]=(x361+(((-1.0)*cj4*new_r22*x360))+new_r00);
evalcond[7]=(((new_r22*x361))+(((-1.0)*cj4*x360))+new_r11);
evalcond[8]=(((new_r22*x359))+((new_r22*x357))+(((-1.0)*x360)));
evalcond[9]=((((-1.0)*cj4*x363))+(((-1.0)*new_r22*x354*x355))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x364=cj4*cj4;
IkReal x365=(cj4*new_r22);
CheckValue<IkReal> x366=IKPowWithIntegerCheck(IKsign(((-1.0)+x364+(((-1.0)*x364*(new_r22*new_r22))))),-1);
if(!x366.valid){
continue;
}
CheckValue<IkReal> x367 = IKatan2WithCheck(IkReal((((new_r00*sj4))+((new_r01*x365)))),IkReal(((((-1.0)*new_r00*x365))+((new_r01*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x367.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x366.value)))+(x367.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x368=IKsin(j6);
IkReal x369=IKcos(j6);
IkReal x370=((1.0)*sj4);
IkReal x371=(cj4*new_r01);
IkReal x372=(new_r10*sj4);
IkReal x373=(new_r11*sj4);
IkReal x374=(cj4*new_r00);
IkReal x375=((1.0)*x369);
IkReal x376=(sj4*x368);
IkReal x377=(new_r22*x368);
IkReal x378=((1.0)*x368);
evalcond[0]=(x377+x373+x371);
evalcond[1]=(x368+((new_r22*x371))+((new_r22*x373)));
evalcond[2]=((((-1.0)*new_r00*x370))+((cj4*new_r10))+(((-1.0)*x378)));
evalcond[3]=(((cj4*new_r11))+(((-1.0)*x375))+(((-1.0)*new_r01*x370)));
evalcond[4]=(((sj4*x369))+((cj4*x377))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x375))+x374+x372);
evalcond[6]=(x376+(((-1.0)*cj4*new_r22*x375))+new_r00);
evalcond[7]=((((-1.0)*cj4*x375))+new_r11+((new_r22*x376)));
evalcond[8]=((((-1.0)*x375))+((new_r22*x372))+((new_r22*x374)));
evalcond[9]=((((-1.0)*cj4*x378))+(((-1.0)*new_r22*x369*x370))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x380=IKPowWithIntegerCheck(sj5,-1);
if(!x380.valid){
continue;
}
IkReal x379=x380.value;
CheckValue<IkReal> x381=IKPowWithIntegerCheck(new_r12,-1);
if(!x381.valid){
continue;
}
if( IKabs((x379*(x381.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x379)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x379*(x381.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))))+IKsqr((new_r02*x379))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x379*(x381.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))), (new_r02*x379));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x382=IKcos(j4);
IkReal x383=IKsin(j4);
IkReal x384=((1.0)*sj5);
IkReal x385=((1.0)*cj5);
IkReal x386=(new_r12*x383);
IkReal x387=(new_r02*x382);
evalcond[0]=(new_r02+(((-1.0)*x382*x384)));
evalcond[1]=(new_r12+(((-1.0)*x383*x384)));
evalcond[2]=(((new_r12*x382))+(((-1.0)*new_r02*x383)));
evalcond[3]=(x386+x387+(((-1.0)*x384)));
evalcond[4]=(((cj5*x386))+((cj5*x387))+(((-1.0)*new_r22*x384)));
evalcond[5]=((((-1.0)*new_r20*x385))+(((-1.0)*new_r00*x382*x384))+(((-1.0)*new_r10*x383*x384)));
evalcond[6]=((((-1.0)*new_r21*x385))+(((-1.0)*new_r01*x382*x384))+(((-1.0)*new_r11*x383*x384)));
evalcond[7]=((1.0)+(((-1.0)*x384*x386))+(((-1.0)*x384*x387))+(((-1.0)*new_r22*x385)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
j6eval[1]=IKsign(new_r12);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x388=IKcos(j6);
IkReal x389=((1.0)*(IKsin(j6)));
evalcond[0]=(x388+new_r20);
evalcond[1]=((((-1.0)*x389))+new_r21);
evalcond[2]=((((-1.0)*x389))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x388))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x390=IKsin(j6);
IkReal x391=((1.0)*(IKcos(j6)));
evalcond[0]=(x390+new_r21);
evalcond[1]=((((-1.0)*x391))+new_r20);
evalcond[2]=((((-1.0)*x390))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x391))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r12);
evalcond[1]=new_r20;
evalcond[2]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x392=IKsin(j6);
IkReal x393=IKcos(j6);
evalcond[0]=x392;
evalcond[1]=((-1.0)*x393);
evalcond[2]=((((-1.0)*x392))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x393))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x394=IKsin(j6);
IkReal x395=IKcos(j6);
evalcond[0]=x394;
evalcond[1]=((-1.0)*x395);
evalcond[2]=((((-1.0)*x394))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x395))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x396=IKsin(j6);
IkReal x397=IKcos(j6);
IkReal x398=((-1.0)*x397);
evalcond[0]=x396;
evalcond[1]=(cj5*x396);
evalcond[2]=x398;
evalcond[3]=(cj5*x398);
evalcond[4]=((((-1.0)*x396))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x397))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x399=IKPowWithIntegerCheck(cj5,-1);
if(!x399.valid){
continue;
}
if( IKabs(((-1.0)*cj5*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r10*(x399.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*cj5*new_r11))+IKsqr((new_r10*(x399.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*cj5*new_r11), (new_r10*(x399.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x400=IKsin(j6);
IkReal x401=IKcos(j6);
IkReal x402=((1.0)*x401);
evalcond[0]=(((cj5*x400))+new_r11);
evalcond[1]=(((cj5*new_r11))+x400);
evalcond[2]=((((-1.0)*cj5*x402))+new_r10);
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x400)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x402)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x402)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x403 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x403.valid){
continue;
}
CheckValue<IkReal> x404=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x404.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x403.value)+(((1.5707963267949)*(x404.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x405=IKsin(j6);
IkReal x406=IKcos(j6);
IkReal x407=((1.0)*x406);
evalcond[0]=(((cj5*x405))+new_r11);
evalcond[1]=(((cj5*new_r11))+x405);
evalcond[2]=((((-1.0)*cj5*x407))+new_r10);
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x405)));
evalcond[4]=((((-1.0)*new_r01))+(((-1.0)*x407)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x407)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x408=IKsin(j6);
IkReal x409=IKcos(j6);
IkReal x410=((-1.0)*x409);
evalcond[0]=x408;
evalcond[1]=(new_r22*x408);
evalcond[2]=x410;
evalcond[3]=(new_r22*x410);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x408)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x409)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x411=IKPowWithIntegerCheck(new_r12,-1);
if(!x411.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x411.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x411.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x411.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x412=IKsin(j6);
IkReal x413=IKcos(j6);
IkReal x414=((1.0)*sj5);
IkReal x415=((1.0)*x413);
IkReal x416=((1.0)*x412);
evalcond[0]=(((new_r12*x413))+new_r20);
evalcond[1]=(((cj5*x412))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x416))+new_r21);
evalcond[3]=((((-1.0)*cj5*x415))+new_r10);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x416)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x415)));
evalcond[6]=(((cj5*new_r11))+x412+(((-1.0)*new_r21*x414)));
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x414))+(((-1.0)*x415)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x417 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x417.valid){
continue;
}
CheckValue<IkReal> x418=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x418.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x417.value)+(((1.5707963267949)*(x418.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x419=IKsin(j6);
IkReal x420=IKcos(j6);
IkReal x421=((1.0)*sj5);
IkReal x422=((1.0)*x420);
IkReal x423=((1.0)*x419);
evalcond[0]=(((new_r12*x420))+new_r20);
evalcond[1]=(((cj5*x419))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x423))+new_r21);
evalcond[3]=((((-1.0)*cj5*x422))+new_r10);
evalcond[4]=((((-1.0)*x423))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x422))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+x419+(((-1.0)*new_r21*x421)));
evalcond[7]=(((cj5*new_r10))+(((-1.0)*x422))+(((-1.0)*new_r20*x421)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x424 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x424.valid){
continue;
}
CheckValue<IkReal> x425=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x425.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x424.value)+(((1.5707963267949)*(x425.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x426=IKsin(j6);
IkReal x427=IKcos(j6);
IkReal x428=((1.0)*sj5);
IkReal x429=((1.0)*x427);
IkReal x430=((1.0)*x426);
evalcond[0]=(((new_r12*x427))+new_r20);
evalcond[1]=(((cj5*x426))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x430))+new_r21);
evalcond[3]=((((-1.0)*cj5*x429))+new_r10);
evalcond[4]=((((-1.0)*x430))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x429))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+x426+(((-1.0)*new_r21*x428)));
evalcond[7]=(((cj5*new_r10))+(((-1.0)*x429))+(((-1.0)*new_r20*x428)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x431=IKsin(j6);
IkReal x432=IKcos(j6);
CheckValue<IkReal> x437=IKPowWithIntegerCheck(new_r12,-1);
if(!x437.valid){
continue;
}
IkReal x433=x437.value;
IkReal x434=new_r22*new_r22;
IkReal x435=((1.0)*x432);
IkReal x436=(x433*x434);
evalcond[0]=(((new_r12*x431))+new_r21);
evalcond[1]=((((-1.0)*x431))+new_r00);
evalcond[2]=((((-1.0)*x435))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x435))+new_r20);
evalcond[4]=(((cj5*x431))+(((-1.0)*new_r11)));
evalcond[5]=((((-1.0)*cj5*x435))+(((-1.0)*new_r10)));
evalcond[6]=(((new_r21*x436))+((new_r12*new_r21))+x431);
evalcond[7]=((((-1.0)*x435))+((new_r12*new_r20))+((new_r20*x436)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x438=IKcos(j6);
IkReal x439=IKsin(j6);
IkReal x440=((1.0)*sj4);
IkReal x441=((1.0)*x439);
IkReal x442=((1.0)*x438);
evalcond[0]=(x438+new_r20);
evalcond[1]=((((-1.0)*x441))+new_r21);
evalcond[2]=(((sj4*x438))+new_r01);
evalcond[3]=(((sj4*x439))+new_r00);
evalcond[4]=((((-1.0)*cj4*x442))+new_r11);
evalcond[5]=((((-1.0)*cj4*x441))+new_r10);
evalcond[6]=((((-1.0)*x441))+(((-1.0)*new_r00*x440))+((cj4*new_r10)));
evalcond[7]=((((-1.0)*x442))+(((-1.0)*new_r01*x440))+((cj4*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x443=IKcos(j6);
IkReal x444=IKsin(j6);
IkReal x445=((1.0)*sj4);
IkReal x446=((1.0)*x443);
IkReal x447=((1.0)*x444);
evalcond[0]=(x444+new_r21);
evalcond[1]=((((-1.0)*x446))+new_r20);
evalcond[2]=(((sj4*x443))+new_r01);
evalcond[3]=(((sj4*x444))+new_r00);
evalcond[4]=((((-1.0)*cj4*x446))+new_r11);
evalcond[5]=((((-1.0)*cj4*x447))+new_r10);
evalcond[6]=((((-1.0)*x447))+(((-1.0)*new_r00*x445))+((cj4*new_r10)));
evalcond[7]=((((-1.0)*x446))+(((-1.0)*new_r01*x445))+((cj4*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x448=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x448))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x448)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x448))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x448))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x448))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x448))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x449=IKsin(j6);
IkReal x450=IKcos(j6);
IkReal x451=((1.0)*sj4);
IkReal x452=((1.0)*x450);
IkReal x453=(sj4*x449);
IkReal x454=(sj4*x450);
IkReal x455=(cj4*x449);
IkReal x456=(cj4*x452);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x449);
evalcond[1]=(x454+x455+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x452)));
evalcond[3]=((((-1.0)*x449))+((cj4*new_r10))+(((-1.0)*new_r00*x451)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x451))+(((-1.0)*x452)));
evalcond[5]=((((-1.0)*x456))+x453+new_r00);
evalcond[6]=((((-1.0)*x456))+x453+new_r11);
evalcond[7]=((((-1.0)*x455))+(((-1.0)*x450*x451))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x457=((1.0)*new_r00);
if( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x457)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x457)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x457))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x457))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x457))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x457))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x458=IKcos(j6);
IkReal x459=IKsin(j6);
IkReal x460=((1.0)*sj4);
IkReal x461=((1.0)*x459);
IkReal x462=(sj4*x458);
IkReal x463=((1.0)*x458);
IkReal x464=(cj4*x461);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x458);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x461)));
evalcond[2]=(((cj4*x458))+((sj4*x459))+new_r00);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x461))+(((-1.0)*new_r00*x460)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x460))+(((-1.0)*x463)));
evalcond[5]=((((-1.0)*x464))+x462+new_r01);
evalcond[6]=((((-1.0)*x464))+x462+new_r10);
evalcond[7]=((((-1.0)*cj4*x463))+(((-1.0)*x459*x460))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x465=IKcos(j6);
IkReal x466=IKsin(j6);
IkReal x467=((1.0)*sj5);
IkReal x468=((1.0)*x465);
IkReal x469=((1.0)*x466);
evalcond[0]=(((new_r02*x465))+new_r20);
evalcond[1]=((((-1.0)*x469))+new_r10);
evalcond[2]=((((-1.0)*x468))+new_r11);
evalcond[3]=(((cj5*x466))+new_r01);
evalcond[4]=((((-1.0)*new_r02*x469))+new_r21);
evalcond[5]=((((-1.0)*cj5*x468))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x467))+((cj5*new_r01))+x466);
evalcond[7]=((((-1.0)*new_r20*x467))+((cj5*new_r00))+(((-1.0)*x468)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=IKsign(new_r02);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x470=IKcos(j6);
IkReal x471=((1.0)*(IKsin(j6)));
evalcond[0]=(x470+new_r20);
evalcond[1]=((((-1.0)*x471))+new_r21);
evalcond[2]=((((-1.0)*x471))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x470))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x472=IKsin(j6);
IkReal x473=((1.0)*(IKcos(j6)));
evalcond[0]=(x472+new_r21);
evalcond[1]=((((-1.0)*x473))+new_r20);
evalcond[2]=((((-1.0)*x472))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x473))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x474=IKsin(j6);
IkReal x475=IKcos(j6);
IkReal x476=((-1.0)*x475);
evalcond[0]=x474;
evalcond[1]=(new_r22*x474);
evalcond[2]=x476;
evalcond[3]=(new_r22*x476);
evalcond[4]=((((-1.0)*x474))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x475))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x477=IKPowWithIntegerCheck(new_r02,-1);
if(!x477.valid){
continue;
}
CheckValue<IkReal> x478=IKPowWithIntegerCheck(cj5,-1);
if(!x478.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x477.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00*(x478.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x477.value)))+IKsqr(((-1.0)*new_r00*(x478.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*(x477.value)), ((-1.0)*new_r00*(x478.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x479=IKsin(j6);
IkReal x480=IKcos(j6);
CheckValue<IkReal> x485=IKPowWithIntegerCheck(new_r02,-1);
if(!x485.valid){
continue;
}
IkReal x481=x485.value;
IkReal x482=new_r22*new_r22;
IkReal x483=((1.0)*x480);
IkReal x484=(x481*x482);
evalcond[0]=(((new_r02*x479))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x483))+new_r20);
evalcond[2]=((((-1.0)*x479))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x483))+(((-1.0)*new_r11)));
evalcond[4]=(((cj5*x479))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*new_r00))+(((-1.0)*cj5*x483)));
evalcond[6]=(((new_r21*x484))+x479+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x483))+((new_r02*new_r20))+((new_r20*x484)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x486=IKPowWithIntegerCheck(new_r02,-1);
if(!x486.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r20*(x486.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr((new_r20*(x486.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), (new_r20*(x486.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x487=IKsin(j6);
IkReal x488=IKcos(j6);
CheckValue<IkReal> x493=IKPowWithIntegerCheck(new_r02,-1);
if(!x493.valid){
continue;
}
IkReal x489=x493.value;
IkReal x490=new_r22*new_r22;
IkReal x491=((1.0)*x488);
IkReal x492=(x489*x490);
evalcond[0]=(((new_r02*x487))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x491))+new_r20);
evalcond[2]=((((-1.0)*x487))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x491))+(((-1.0)*new_r11)));
evalcond[4]=(((cj5*x487))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*cj5*x491))+(((-1.0)*new_r00)));
evalcond[6]=(((new_r21*x492))+x487+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x491))+((new_r20*x492))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x494 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x494.valid){
continue;
}
CheckValue<IkReal> x495=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x495.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x494.value)+(((1.5707963267949)*(x495.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x496=IKsin(j6);
IkReal x497=IKcos(j6);
CheckValue<IkReal> x502=IKPowWithIntegerCheck(new_r02,-1);
if(!x502.valid){
continue;
}
IkReal x498=x502.value;
IkReal x499=new_r22*new_r22;
IkReal x500=((1.0)*x497);
IkReal x501=(x498*x499);
evalcond[0]=(((new_r02*x496))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x500))+new_r20);
evalcond[2]=((((-1.0)*x496))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x500))+(((-1.0)*new_r11)));
evalcond[4]=(((cj5*x496))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*cj5*x500))+(((-1.0)*new_r00)));
evalcond[6]=(x496+((new_r21*x501))+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x500))+((new_r02*new_r20))+((new_r20*x501)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x504=IKPowWithIntegerCheck(sj5,-1);
if(!x504.valid){
continue;
}
IkReal x503=x504.value;
CheckValue<IkReal> x505=IKPowWithIntegerCheck(cj4,-1);
if(!x505.valid){
continue;
}
CheckValue<IkReal> x506=IKPowWithIntegerCheck(cj5,-1);
if(!x506.valid){
continue;
}
if( IKabs((x503*(x505.value)*(x506.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x503)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x503*(x505.value)*(x506.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x503))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x503*(x505.value)*(x506.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x503));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x507=IKsin(j6);
IkReal x508=IKcos(j6);
IkReal x509=((1.0)*sj5);
IkReal x510=((1.0)*sj4);
IkReal x511=(cj5*sj4);
IkReal x512=(cj4*new_r01);
IkReal x513=(cj4*new_r00);
IkReal x514=((1.0)*x508);
IkReal x515=(cj5*x507);
IkReal x516=((1.0)*x507);
evalcond[0]=(((sj5*x508))+new_r20);
evalcond[1]=((((-1.0)*x507*x509))+new_r21);
evalcond[2]=(((new_r11*sj4))+x515+x512);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x510))+(((-1.0)*x516)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x510))+(((-1.0)*x514)));
evalcond[5]=(((cj4*x515))+((sj4*x508))+new_r01);
evalcond[6]=(((new_r10*sj4))+x513+(((-1.0)*cj5*x514)));
evalcond[7]=((((-1.0)*cj4*cj5*x514))+((sj4*x507))+new_r00);
evalcond[8]=(((x507*x511))+(((-1.0)*cj4*x514))+new_r11);
evalcond[9]=((((-1.0)*cj4*x516))+new_r10+(((-1.0)*cj5*x508*x510)));
evalcond[10]=((((-1.0)*new_r21*x509))+((cj5*x512))+((new_r11*x511))+x507);
evalcond[11]=(((cj5*x513))+((new_r10*x511))+(((-1.0)*new_r20*x509))+(((-1.0)*x514)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x518=IKPowWithIntegerCheck(sj5,-1);
if(!x518.valid){
continue;
}
IkReal x517=x518.value;
CheckValue<IkReal> x519=IKPowWithIntegerCheck(sj4,-1);
if(!x519.valid){
continue;
}
if( IKabs((x517*(x519.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x517)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x517*(x519.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x517))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x517*(x519.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x517));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x520=IKsin(j6);
IkReal x521=IKcos(j6);
IkReal x522=((1.0)*sj5);
IkReal x523=((1.0)*sj4);
IkReal x524=(cj5*sj4);
IkReal x525=(cj4*new_r01);
IkReal x526=(cj4*new_r00);
IkReal x527=((1.0)*x521);
IkReal x528=(cj5*x520);
IkReal x529=((1.0)*x520);
evalcond[0]=(((sj5*x521))+new_r20);
evalcond[1]=((((-1.0)*x520*x522))+new_r21);
evalcond[2]=(((new_r11*sj4))+x525+x528);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x523))+(((-1.0)*x529)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x527))+(((-1.0)*new_r01*x523)));
evalcond[5]=(((cj4*x528))+new_r01+((sj4*x521)));
evalcond[6]=(((new_r10*sj4))+x526+(((-1.0)*cj5*x527)));
evalcond[7]=((((-1.0)*cj4*cj5*x527))+new_r00+((sj4*x520)));
evalcond[8]=(((x520*x524))+new_r11+(((-1.0)*cj4*x527)));
evalcond[9]=((((-1.0)*cj5*x521*x523))+new_r10+(((-1.0)*cj4*x529)));
evalcond[10]=(((cj5*x525))+((new_r11*x524))+(((-1.0)*new_r21*x522))+x520);
evalcond[11]=(((cj5*x526))+(((-1.0)*new_r20*x522))+(((-1.0)*x527))+((new_r10*x524)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x530=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x530.valid){
continue;
}
CheckValue<IkReal> x531 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x531.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x530.value)))+(x531.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x532=IKsin(j6);
IkReal x533=IKcos(j6);
IkReal x534=((1.0)*sj5);
IkReal x535=((1.0)*sj4);
IkReal x536=(cj5*sj4);
IkReal x537=(cj4*new_r01);
IkReal x538=(cj4*new_r00);
IkReal x539=((1.0)*x533);
IkReal x540=(cj5*x532);
IkReal x541=((1.0)*x532);
evalcond[0]=(((sj5*x533))+new_r20);
evalcond[1]=((((-1.0)*x532*x534))+new_r21);
evalcond[2]=(((new_r11*sj4))+x540+x537);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x535))+(((-1.0)*x541)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x539))+(((-1.0)*new_r01*x535)));
evalcond[5]=(((cj4*x540))+new_r01+((sj4*x533)));
evalcond[6]=(((new_r10*sj4))+x538+(((-1.0)*cj5*x539)));
evalcond[7]=((((-1.0)*cj4*cj5*x539))+new_r00+((sj4*x532)));
evalcond[8]=(new_r11+(((-1.0)*cj4*x539))+((x532*x536)));
evalcond[9]=((((-1.0)*cj5*x533*x535))+new_r10+(((-1.0)*cj4*x541)));
evalcond[10]=(((cj5*x537))+((new_r11*x536))+(((-1.0)*new_r21*x534))+x532);
evalcond[11]=(((cj5*x538))+(((-1.0)*x539))+((new_r10*x536))+(((-1.0)*new_r20*x534)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x542=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x542.valid){
continue;
}
CheckValue<IkReal> x543 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x543.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x542.value)))+(x543.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
evalcond[0]=(new_r20+((sj5*(IKcos(j6)))));
evalcond[1]=((((-1.0)*sj5*(IKsin(j6))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=cj6;
j4eval[1]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j6)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x544=IKsin(j4);
IkReal x545=IKcos(j4);
IkReal x546=((1.0)*sj5);
IkReal x547=(new_r22*x544);
IkReal x548=(new_r11*x544);
IkReal x549=(new_r02*x545);
IkReal x550=(new_r22*x545);
IkReal x551=(new_r12*x544);
IkReal x552=(new_r10*x544);
IkReal x553=((1.0)*x544);
IkReal x554=(x545*x546);
evalcond[0]=(x544+new_r00);
evalcond[1]=(x550+new_r01);
evalcond[2]=(x547+new_r11);
evalcond[3]=((((-1.0)*x545))+new_r10);
evalcond[4]=((((-1.0)*x554))+new_r02);
evalcond[5]=((((-1.0)*x544*x546))+new_r12);
evalcond[6]=(((new_r00*x545))+x552);
evalcond[7]=(((new_r12*x545))+(((-1.0)*new_r02*x553)));
evalcond[8]=((((-1.0)*new_r01*x553))+((new_r11*x545)));
evalcond[9]=(x548+new_r22+((new_r01*x545)));
evalcond[10]=((-1.0)+((new_r10*x545))+(((-1.0)*new_r00*x553)));
evalcond[11]=(((new_r10*x547))+((new_r00*x550)));
evalcond[12]=((((-1.0)*x546))+x551+x549);
evalcond[13]=((((-1.0)*new_r00*x554))+(((-1.0)*x546*x552)));
evalcond[14]=((((-1.0)*new_r22*x546))+((new_r12*x547))+((new_r22*x549)));
evalcond[15]=((((-1.0)*cj5*new_r21))+(((-1.0)*new_r01*x554))+(((-1.0)*x546*x548)));
evalcond[16]=((1.0)+(((-1.0)*sj5*x546))+((new_r11*x547))+((new_r01*x550)));
evalcond[17]=((1.0)+(((-1.0)*(new_r22*new_r22)))+(((-1.0)*x546*x551))+(((-1.0)*x546*x549)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j6)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x555=IKcos(j4);
IkReal x556=IKsin(j4);
IkReal x557=(new_r22*sj5);
IkReal x558=((1.0)*sj5);
IkReal x559=((1.0)*x555);
IkReal x560=(new_r22*x556);
IkReal x561=(new_r11*x556);
IkReal x562=(new_r02*x555);
IkReal x563=(new_r01*x555);
IkReal x564=(new_r12*x556);
IkReal x565=((1.0)*x556);
IkReal x566=(new_r10*x556);
IkReal x567=(new_r00*x555);
evalcond[0]=(x555+new_r10);
evalcond[1]=(new_r00+(((-1.0)*x565)));
evalcond[2]=((((-1.0)*x555*x558))+new_r02);
evalcond[3]=((((-1.0)*x556*x558))+new_r12);
evalcond[4]=((((-1.0)*new_r22*x559))+new_r01);
evalcond[5]=((((-1.0)*x560))+new_r11);
evalcond[6]=(x566+x567);
evalcond[7]=((((-1.0)*new_r02*x565))+((new_r12*x555)));
evalcond[8]=(((new_r11*x555))+(((-1.0)*new_r01*x565)));
evalcond[9]=((1.0)+(((-1.0)*new_r00*x565))+((new_r10*x555)));
evalcond[10]=(((new_r22*x567))+((new_r10*x560)));
evalcond[11]=((((-1.0)*x558))+x564+x562);
evalcond[12]=((((-1.0)*new_r22))+x563+x561);
evalcond[13]=((((-1.0)*x558*x566))+(((-1.0)*x558*x567)));
evalcond[14]=((((-1.0)*x557))+((new_r22*x562))+((new_r12*x560)));
evalcond[15]=((-1.0)+((new_r22*x563))+((new_r11*x560))+(sj5*sj5));
evalcond[16]=((((-1.0)*x558*x561))+(((-1.0)*x558*x563))+x557);
evalcond[17]=((1.0)+(((-1.0)*x558*x562))+(((-1.0)*x558*x564))+(((-1.0)*(new_r22*new_r22))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x568=((1.0)*sj6);
if( IKabs(((((-1.0)*new_r00*x568))+(((-1.0)*cj6*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj6*new_r00))+(((-1.0)*new_r01*x568)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x568))+(((-1.0)*cj6*new_r01))))+IKsqr((((cj6*new_r00))+(((-1.0)*new_r01*x568))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*new_r00*x568))+(((-1.0)*cj6*new_r01))), (((cj6*new_r00))+(((-1.0)*new_r01*x568))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x569=IKcos(j4);
IkReal x570=IKsin(j4);
IkReal x571=((1.0)*cj6);
IkReal x572=(sj6*x570);
IkReal x573=(cj6*x570);
IkReal x574=(sj6*x569);
IkReal x575=((1.0)*x570);
IkReal x576=(x569*x571);
evalcond[0]=(sj6+((new_r11*x570))+((new_r01*x569)));
evalcond[1]=(x574+x573+new_r01);
evalcond[2]=((((-1.0)*x576))+x572+new_r00);
evalcond[3]=((((-1.0)*x576))+x572+new_r11);
evalcond[4]=(((new_r10*x570))+((new_r00*x569))+(((-1.0)*x571)));
evalcond[5]=((((-1.0)*x570*x571))+(((-1.0)*x574))+new_r10);
evalcond[6]=((((-1.0)*sj6))+(((-1.0)*new_r00*x575))+((new_r10*x569)));
evalcond[7]=((((-1.0)*x571))+((new_r11*x569))+(((-1.0)*new_r01*x575)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x577=((1.0)*new_r00);
if( IKabs(((((-1.0)*cj6*new_r01))+(((-1.0)*sj6*x577)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj6))+(((-1.0)*cj6*x577)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj6*new_r01))+(((-1.0)*sj6*x577))))+IKsqr((((new_r01*sj6))+(((-1.0)*cj6*x577))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj6*new_r01))+(((-1.0)*sj6*x577))), (((new_r01*sj6))+(((-1.0)*cj6*x577))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x578=IKsin(j4);
IkReal x579=IKcos(j4);
IkReal x580=((1.0)*sj6);
IkReal x581=(cj6*x578);
IkReal x582=(cj6*x579);
IkReal x583=((1.0)*x578);
IkReal x584=(x579*x580);
evalcond[0]=(((new_r00*x579))+cj6+((new_r10*x578)));
evalcond[1]=(((sj6*x578))+x582+new_r00);
evalcond[2]=(x581+new_r01+(((-1.0)*x584)));
evalcond[3]=(x581+new_r10+(((-1.0)*x584)));
evalcond[4]=(((new_r11*x578))+((new_r01*x579))+(((-1.0)*x580)));
evalcond[5]=((((-1.0)*x582))+(((-1.0)*x578*x580))+new_r11);
evalcond[6]=(((new_r10*x579))+(((-1.0)*x580))+(((-1.0)*new_r00*x583)));
evalcond[7]=((((-1.0)*new_r01*x583))+((new_r11*x579))+(((-1.0)*cj6)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x586 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x586.valid){
continue;
}
IkReal x585=x586.value;
j4array[0]=((-1.0)*x585);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x585)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x587=IKcos(j4);
IkReal x588=IKsin(j4);
IkReal x589=(new_r00*x587);
IkReal x590=(new_r10*x588);
IkReal x591=((1.0)*x588);
evalcond[0]=(((new_r01*x587))+((new_r11*x588)));
evalcond[1]=(x589+x590);
evalcond[2]=((((-1.0)*new_r00*x591))+((new_r10*x587)));
evalcond[3]=((((-1.0)*new_r01*x591))+((new_r11*x587)));
evalcond[4]=(((new_r22*x589))+((new_r22*x590)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x593 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x593.valid){
continue;
}
IkReal x592=x593.value;
j4array[0]=((-1.0)*x592);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x592)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x594=IKcos(j4);
IkReal x595=IKsin(j4);
IkReal x596=(new_r01*x594);
IkReal x597=(new_r11*x595);
IkReal x598=((1.0)*x595);
evalcond[0]=(x597+x596);
evalcond[1]=((((-1.0)*new_r00*x598))+((new_r10*x594)));
evalcond[2]=(((new_r11*x594))+(((-1.0)*new_r01*x598)));
evalcond[3]=(((new_r22*x596))+((new_r22*x597)));
evalcond[4]=(((new_r10*new_r22*x595))+((new_r00*new_r22*x594)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x600 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x600.valid){
continue;
}
IkReal x599=x600.value;
j4array[0]=((-1.0)*x599);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x599)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x601=IKcos(j4);
IkReal x602=IKsin(j4);
IkReal x603=(new_r00*x601);
IkReal x604=(new_r22*x602);
IkReal x605=((1.0)*x602);
evalcond[0]=(((new_r10*x602))+x603);
evalcond[1]=(((new_r10*x601))+(((-1.0)*new_r00*x605)));
evalcond[2]=(((new_r11*x601))+(((-1.0)*new_r01*x605)));
evalcond[3]=(((new_r11*x604))+((new_r01*new_r22*x601)));
evalcond[4]=(((new_r22*x603))+((new_r10*x604)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x607=IKPowWithIntegerCheck(sj5,-1);
if(!x607.valid){
continue;
}
IkReal x606=x607.value;
CheckValue<IkReal> x608=IKPowWithIntegerCheck(cj6,-1);
if(!x608.valid){
continue;
}
if( IKabs((x606*(x608.value)*(((((-1.0)*new_r01*sj5))+(((-1.0)*cj5*new_r02*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x606)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x606*(x608.value)*(((((-1.0)*new_r01*sj5))+(((-1.0)*cj5*new_r02*sj6))))))+IKsqr((new_r02*x606))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x606*(x608.value)*(((((-1.0)*new_r01*sj5))+(((-1.0)*cj5*new_r02*sj6))))), (new_r02*x606));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x609=IKcos(j4);
IkReal x610=IKsin(j4);
IkReal x611=((1.0)*cj6);
IkReal x612=(cj5*sj6);
IkReal x613=((1.0)*cj5);
IkReal x614=((1.0)*sj5);
IkReal x615=((1.0)*x609);
IkReal x616=(cj5*x610);
IkReal x617=(new_r11*x610);
IkReal x618=(cj5*x609);
IkReal x619=(new_r12*x610);
IkReal x620=(new_r10*x610);
IkReal x621=((1.0)*x610);
evalcond[0]=((((-1.0)*x609*x614))+new_r02);
evalcond[1]=((((-1.0)*x610*x614))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x621))+((new_r12*x609)));
evalcond[3]=(((cj6*x610))+((x609*x612))+new_r01);
evalcond[4]=((((-1.0)*x614))+x619+((new_r02*x609)));
evalcond[5]=(x617+x612+((new_r01*x609)));
evalcond[6]=((((-1.0)*x611*x618))+new_r00+((sj6*x610)));
evalcond[7]=((((-1.0)*x609*x611))+new_r11+((x610*x612)));
evalcond[8]=((((-1.0)*sj6))+(((-1.0)*new_r00*x621))+((new_r10*x609)));
evalcond[9]=((((-1.0)*new_r01*x621))+((new_r11*x609))+(((-1.0)*x611)));
evalcond[10]=((((-1.0)*cj5*x611))+x620+((new_r00*x609)));
evalcond[11]=((((-1.0)*sj6*x615))+(((-1.0)*x611*x616))+new_r10);
evalcond[12]=(((new_r12*x616))+((new_r02*x618))+(((-1.0)*new_r22*x614)));
evalcond[13]=(sj6+(((-1.0)*new_r21*x614))+((new_r11*x616))+((new_r01*x618)));
evalcond[14]=((((-1.0)*x614*x620))+(((-1.0)*new_r20*x613))+(((-1.0)*new_r00*x609*x614)));
evalcond[15]=((((-1.0)*x614*x617))+(((-1.0)*new_r21*x613))+(((-1.0)*new_r01*x609*x614)));
evalcond[16]=((1.0)+(((-1.0)*x614*x619))+(((-1.0)*new_r02*x609*x614))+(((-1.0)*new_r22*x613)));
evalcond[17]=(((new_r10*x616))+(((-1.0)*x611))+(((-1.0)*new_r20*x614))+((new_r00*x618)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x622=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x622.valid){
continue;
}
CheckValue<IkReal> x623 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x623.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x622.value)))+(x623.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x624=IKcos(j4);
IkReal x625=IKsin(j4);
IkReal x626=((1.0)*cj6);
IkReal x627=(cj5*sj6);
IkReal x628=((1.0)*cj5);
IkReal x629=((1.0)*sj5);
IkReal x630=((1.0)*x624);
IkReal x631=(cj5*x625);
IkReal x632=(new_r11*x625);
IkReal x633=(cj5*x624);
IkReal x634=(new_r12*x625);
IkReal x635=(new_r10*x625);
IkReal x636=((1.0)*x625);
evalcond[0]=((((-1.0)*x624*x629))+new_r02);
evalcond[1]=((((-1.0)*x625*x629))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x636))+((new_r12*x624)));
evalcond[3]=(((x624*x627))+new_r01+((cj6*x625)));
evalcond[4]=(((new_r02*x624))+(((-1.0)*x629))+x634);
evalcond[5]=(((new_r01*x624))+x627+x632);
evalcond[6]=(((sj6*x625))+new_r00+(((-1.0)*x626*x633)));
evalcond[7]=(((x625*x627))+(((-1.0)*x624*x626))+new_r11);
evalcond[8]=((((-1.0)*sj6))+(((-1.0)*new_r00*x636))+((new_r10*x624)));
evalcond[9]=((((-1.0)*new_r01*x636))+(((-1.0)*x626))+((new_r11*x624)));
evalcond[10]=(((new_r00*x624))+(((-1.0)*cj5*x626))+x635);
evalcond[11]=((((-1.0)*sj6*x630))+new_r10+(((-1.0)*x626*x631)));
evalcond[12]=(((new_r02*x633))+(((-1.0)*new_r22*x629))+((new_r12*x631)));
evalcond[13]=(sj6+((new_r01*x633))+(((-1.0)*new_r21*x629))+((new_r11*x631)));
evalcond[14]=((((-1.0)*x629*x635))+(((-1.0)*new_r00*x624*x629))+(((-1.0)*new_r20*x628)));
evalcond[15]=((((-1.0)*x629*x632))+(((-1.0)*new_r21*x628))+(((-1.0)*new_r01*x624*x629)));
evalcond[16]=((1.0)+(((-1.0)*x629*x634))+(((-1.0)*new_r02*x624*x629))+(((-1.0)*new_r22*x628)));
evalcond[17]=((((-1.0)*x626))+((new_r00*x633))+(((-1.0)*new_r20*x629))+((new_r10*x631)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x637=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x637.valid){
continue;
}
CheckValue<IkReal> x638 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x638.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x637.value)))+(x638.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x639=IKcos(j4);
IkReal x640=IKsin(j4);
IkReal x641=((1.0)*sj5);
IkReal x642=((1.0)*cj5);
IkReal x643=(new_r12*x640);
IkReal x644=(new_r02*x639);
evalcond[0]=((((-1.0)*x639*x641))+new_r02);
evalcond[1]=((((-1.0)*x640*x641))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x640))+((new_r12*x639)));
evalcond[3]=((((-1.0)*x641))+x644+x643);
evalcond[4]=(((cj5*x643))+((cj5*x644))+(((-1.0)*new_r22*x641)));
evalcond[5]=((((-1.0)*new_r10*x640*x641))+(((-1.0)*new_r00*x639*x641))+(((-1.0)*new_r20*x642)));
evalcond[6]=((((-1.0)*new_r01*x639*x641))+(((-1.0)*new_r21*x642))+(((-1.0)*new_r11*x640*x641)));
evalcond[7]=((1.0)+(((-1.0)*x641*x643))+(((-1.0)*x641*x644))+(((-1.0)*new_r22*x642)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=sj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=cj4;
j6eval[1]=cj5;
j6eval[2]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
j6eval[1]=IKsign(new_r12);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
j6eval[0]=new_r12;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x645=IKcos(j6);
IkReal x646=((1.0)*(IKsin(j6)));
evalcond[0]=(x645+new_r20);
evalcond[1]=((((-1.0)*x646))+new_r21);
evalcond[2]=((((-1.0)*x646))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x645))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r11;
evalcond[3]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x647=IKsin(j6);
IkReal x648=((1.0)*(IKcos(j6)));
evalcond[0]=(x647+new_r21);
evalcond[1]=((((-1.0)*x648))+new_r20);
evalcond[2]=((((-1.0)*x647))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x648))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r12);
evalcond[1]=new_r20;
evalcond[2]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
j6eval[1]=IKsign(cj5);
j6eval[2]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
new_r12=0;
j6eval[0]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x649=IKsin(j6);
IkReal x650=IKcos(j6);
evalcond[0]=x649;
evalcond[1]=((-1.0)*x650);
evalcond[2]=((((-1.0)*x649))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x650))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r11;
evalcond[2]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x651=IKsin(j6);
IkReal x652=IKcos(j6);
evalcond[0]=x651;
evalcond[1]=((-1.0)*x652);
evalcond[2]=((((-1.0)*x651))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x652))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x653=IKsin(j6);
IkReal x654=IKcos(j6);
IkReal x655=((-1.0)*x654);
evalcond[0]=x653;
evalcond[1]=(cj5*x653);
evalcond[2]=x655;
evalcond[3]=(cj5*x655);
evalcond[4]=((((-1.0)*x653))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x654))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x656=IKPowWithIntegerCheck(cj5,-1);
if(!x656.valid){
continue;
}
if( IKabs(((-1.0)*cj5*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r10*(x656.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*cj5*new_r11))+IKsqr((new_r10*(x656.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*cj5*new_r11), (new_r10*(x656.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x657=IKsin(j6);
IkReal x658=IKcos(j6);
IkReal x659=((1.0)*x658);
evalcond[0]=(((cj5*x657))+new_r11);
evalcond[1]=(((cj5*new_r11))+x657);
evalcond[2]=(new_r10+(((-1.0)*cj5*x659)));
evalcond[3]=((((-1.0)*x657))+(((-1.0)*new_r00)));
evalcond[4]=((((-1.0)*x659))+(((-1.0)*new_r01)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x659)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x660 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x660.valid){
continue;
}
CheckValue<IkReal> x661=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x661.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x660.value)+(((1.5707963267949)*(x661.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x662=IKsin(j6);
IkReal x663=IKcos(j6);
IkReal x664=((1.0)*x663);
evalcond[0]=(new_r11+((cj5*x662)));
evalcond[1]=(((cj5*new_r11))+x662);
evalcond[2]=((((-1.0)*cj5*x664))+new_r10);
evalcond[3]=((((-1.0)*x662))+(((-1.0)*new_r00)));
evalcond[4]=((((-1.0)*x664))+(((-1.0)*new_r01)));
evalcond[5]=(((cj5*new_r10))+(((-1.0)*x664)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x665=IKsin(j6);
IkReal x666=IKcos(j6);
IkReal x667=((-1.0)*x666);
evalcond[0]=x665;
evalcond[1]=(new_r22*x665);
evalcond[2]=x667;
evalcond[3]=(new_r22*x667);
evalcond[4]=((((-1.0)*x665))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x666))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x668=IKPowWithIntegerCheck(new_r12,-1);
if(!x668.valid){
continue;
}
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x668.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r20*(x668.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r20*(x668.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x669=IKsin(j6);
IkReal x670=IKcos(j6);
IkReal x671=((1.0)*sj5);
IkReal x672=((1.0)*x670);
IkReal x673=((1.0)*x669);
evalcond[0]=(((new_r12*x670))+new_r20);
evalcond[1]=(new_r11+((cj5*x669)));
evalcond[2]=((((-1.0)*new_r12*x673))+new_r21);
evalcond[3]=((((-1.0)*cj5*x672))+new_r10);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x673)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x672)));
evalcond[6]=((((-1.0)*new_r21*x671))+((cj5*new_r11))+x669);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x671))+(((-1.0)*x672)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x674 = IKatan2WithCheck(IkReal(((-1.0)*new_r11)),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x674.valid){
continue;
}
CheckValue<IkReal> x675=IKPowWithIntegerCheck(IKsign(cj5),-1);
if(!x675.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x674.value)+(((1.5707963267949)*(x675.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x676=IKsin(j6);
IkReal x677=IKcos(j6);
IkReal x678=((1.0)*sj5);
IkReal x679=((1.0)*x677);
IkReal x680=((1.0)*x676);
evalcond[0]=(((new_r12*x677))+new_r20);
evalcond[1]=(((cj5*x676))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x680))+new_r21);
evalcond[3]=((((-1.0)*cj5*x679))+new_r10);
evalcond[4]=((((-1.0)*x680))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x679)));
evalcond[6]=((((-1.0)*new_r21*x678))+((cj5*new_r11))+x676);
evalcond[7]=(((cj5*new_r10))+(((-1.0)*new_r20*x678))+(((-1.0)*x679)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x681 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x681.valid){
continue;
}
CheckValue<IkReal> x682=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x682.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x681.value)+(((1.5707963267949)*(x682.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x683=IKsin(j6);
IkReal x684=IKcos(j6);
IkReal x685=((1.0)*sj5);
IkReal x686=((1.0)*x684);
IkReal x687=((1.0)*x683);
evalcond[0]=(((new_r12*x684))+new_r20);
evalcond[1]=(((cj5*x683))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x687))+new_r21);
evalcond[3]=((((-1.0)*cj5*x686))+new_r10);
evalcond[4]=((((-1.0)*x687))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x686))+(((-1.0)*new_r01)));
evalcond[6]=(((cj5*new_r11))+(((-1.0)*new_r21*x685))+x683);
evalcond[7]=((((-1.0)*x686))+((cj5*new_r10))+(((-1.0)*new_r20*x685)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x688=IKsin(j6);
IkReal x689=IKcos(j6);
CheckValue<IkReal> x694=IKPowWithIntegerCheck(new_r12,-1);
if(!x694.valid){
continue;
}
IkReal x690=x694.value;
IkReal x691=new_r22*new_r22;
IkReal x692=((1.0)*x689);
IkReal x693=(x690*x691);
evalcond[0]=(((new_r12*x688))+new_r21);
evalcond[1]=(new_r00+(((-1.0)*x688)));
evalcond[2]=((((-1.0)*x692))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x692))+new_r20);
evalcond[4]=(((cj5*x688))+(((-1.0)*new_r11)));
evalcond[5]=((((-1.0)*cj5*x692))+(((-1.0)*new_r10)));
evalcond[6]=(((new_r21*x693))+((new_r12*new_r21))+x688);
evalcond[7]=(((new_r12*new_r20))+((new_r20*x693))+(((-1.0)*x692)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x695=IKcos(j6);
IkReal x696=IKsin(j6);
IkReal x697=((1.0)*sj4);
IkReal x698=((1.0)*x696);
IkReal x699=((1.0)*x695);
evalcond[0]=(x695+new_r20);
evalcond[1]=((((-1.0)*x698))+new_r21);
evalcond[2]=(((sj4*x695))+new_r01);
evalcond[3]=(((sj4*x696))+new_r00);
evalcond[4]=((((-1.0)*cj4*x699))+new_r11);
evalcond[5]=((((-1.0)*cj4*x698))+new_r10);
evalcond[6]=(((cj4*new_r10))+(((-1.0)*new_r00*x697))+(((-1.0)*x698)));
evalcond[7]=(((cj4*new_r11))+(((-1.0)*new_r01*x697))+(((-1.0)*x699)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x700=IKcos(j6);
IkReal x701=IKsin(j6);
IkReal x702=((1.0)*sj4);
IkReal x703=((1.0)*x700);
IkReal x704=((1.0)*x701);
evalcond[0]=(x701+new_r21);
evalcond[1]=((((-1.0)*x703))+new_r20);
evalcond[2]=(new_r01+((sj4*x700)));
evalcond[3]=(new_r00+((sj4*x701)));
evalcond[4]=(new_r11+(((-1.0)*cj4*x703)));
evalcond[5]=(new_r10+(((-1.0)*cj4*x704)));
evalcond[6]=(((cj4*new_r10))+(((-1.0)*x704))+(((-1.0)*new_r00*x702)));
evalcond[7]=(((cj4*new_r11))+(((-1.0)*x703))+(((-1.0)*new_r01*x702)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x705=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x705)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj4*x705))+((cj4*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x705))))+IKsqr(((((-1.0)*sj4*x705))+((cj4*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x705))), ((((-1.0)*sj4*x705))+((cj4*new_r00))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x706=IKsin(j6);
IkReal x707=IKcos(j6);
IkReal x708=((1.0)*sj4);
IkReal x709=((1.0)*x707);
IkReal x710=(sj4*x706);
IkReal x711=(sj4*x707);
IkReal x712=(cj4*x706);
IkReal x713=(cj4*x709);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x706);
evalcond[1]=(x711+x712+new_r01);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x709)));
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x706))+(((-1.0)*new_r00*x708)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x709))+(((-1.0)*new_r01*x708)));
evalcond[5]=((((-1.0)*x713))+x710+new_r00);
evalcond[6]=((((-1.0)*x713))+x710+new_r11);
evalcond[7]=((((-1.0)*x707*x708))+(((-1.0)*x712))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x714=((1.0)*new_r00);
if( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x714)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x714)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x714))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x714))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x714))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x714))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x715=IKcos(j6);
IkReal x716=IKsin(j6);
IkReal x717=((1.0)*sj4);
IkReal x718=((1.0)*x716);
IkReal x719=(sj4*x715);
IkReal x720=((1.0)*x715);
IkReal x721=(cj4*x718);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x715);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x718)));
evalcond[2]=(((sj4*x716))+((cj4*x715))+new_r00);
evalcond[3]=(((cj4*new_r10))+(((-1.0)*x718))+(((-1.0)*new_r00*x717)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x720))+(((-1.0)*new_r01*x717)));
evalcond[5]=((((-1.0)*x721))+x719+new_r01);
evalcond[6]=((((-1.0)*x721))+x719+new_r10);
evalcond[7]=((((-1.0)*x716*x717))+(((-1.0)*cj4*x720))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x722=IKcos(j6);
IkReal x723=IKsin(j6);
IkReal x724=((1.0)*sj5);
IkReal x725=((1.0)*x722);
IkReal x726=((1.0)*x723);
evalcond[0]=(((new_r02*x722))+new_r20);
evalcond[1]=((((-1.0)*x726))+new_r10);
evalcond[2]=((((-1.0)*x725))+new_r11);
evalcond[3]=(((cj5*x723))+new_r01);
evalcond[4]=((((-1.0)*new_r02*x726))+new_r21);
evalcond[5]=((((-1.0)*cj5*x725))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x724))+((cj5*new_r01))+x723);
evalcond[7]=((((-1.0)*new_r20*x724))+((cj5*new_r00))+(((-1.0)*x725)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=IKsign(new_r02);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j6eval[0]=new_r02;
j6eval[1]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x727=IKcos(j6);
IkReal x728=((1.0)*(IKsin(j6)));
evalcond[0]=(x727+new_r20);
evalcond[1]=((((-1.0)*x728))+new_r21);
evalcond[2]=((((-1.0)*x728))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x727))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x729=IKsin(j6);
IkReal x730=((1.0)*(IKcos(j6)));
evalcond[0]=(x729+new_r21);
evalcond[1]=((((-1.0)*x730))+new_r20);
evalcond[2]=((((-1.0)*x729))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x730))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x731=IKsin(j6);
IkReal x732=IKcos(j6);
IkReal x733=((-1.0)*x732);
evalcond[0]=x731;
evalcond[1]=(new_r22*x731);
evalcond[2]=x733;
evalcond[3]=(new_r22*x733);
evalcond[4]=((((-1.0)*x731))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x732))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x734=IKPowWithIntegerCheck(new_r02,-1);
if(!x734.valid){
continue;
}
CheckValue<IkReal> x735=IKPowWithIntegerCheck(cj5,-1);
if(!x735.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x734.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00*(x735.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x734.value)))+IKsqr(((-1.0)*new_r00*(x735.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*(x734.value)), ((-1.0)*new_r00*(x735.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x736=IKsin(j6);
IkReal x737=IKcos(j6);
CheckValue<IkReal> x742=IKPowWithIntegerCheck(new_r02,-1);
if(!x742.valid){
continue;
}
IkReal x738=x742.value;
IkReal x739=new_r22*new_r22;
IkReal x740=((1.0)*x737);
IkReal x741=(x738*x739);
evalcond[0]=(((new_r02*x736))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x740))+new_r20);
evalcond[2]=((((-1.0)*x736))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x740)));
evalcond[4]=(((cj5*x736))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*cj5*x740))+(((-1.0)*new_r00)));
evalcond[6]=(x736+((new_r02*new_r21))+((new_r21*x741)));
evalcond[7]=(((new_r20*x741))+((new_r02*new_r20))+(((-1.0)*x740)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x743=IKPowWithIntegerCheck(new_r02,-1);
if(!x743.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r20*(x743.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr((new_r20*(x743.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r10), (new_r20*(x743.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x744=IKsin(j6);
IkReal x745=IKcos(j6);
CheckValue<IkReal> x750=IKPowWithIntegerCheck(new_r02,-1);
if(!x750.valid){
continue;
}
IkReal x746=x750.value;
IkReal x747=new_r22*new_r22;
IkReal x748=((1.0)*x745);
IkReal x749=(x746*x747);
evalcond[0]=(new_r21+((new_r02*x744)));
evalcond[1]=((((-1.0)*new_r02*x748))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x744)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x748)));
evalcond[4]=((((-1.0)*new_r01))+((cj5*x744)));
evalcond[5]=((((-1.0)*cj5*x748))+(((-1.0)*new_r00)));
evalcond[6]=(x744+((new_r02*new_r21))+((new_r21*x749)));
evalcond[7]=(((new_r20*x749))+((new_r02*new_r20))+(((-1.0)*x748)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x751 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),IkReal(new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x751.valid){
continue;
}
CheckValue<IkReal> x752=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x752.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x751.value)+(((1.5707963267949)*(x752.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x753=IKsin(j6);
IkReal x754=IKcos(j6);
CheckValue<IkReal> x759=IKPowWithIntegerCheck(new_r02,-1);
if(!x759.valid){
continue;
}
IkReal x755=x759.value;
IkReal x756=new_r22*new_r22;
IkReal x757=((1.0)*x754);
IkReal x758=(x755*x756);
evalcond[0]=(new_r21+((new_r02*x753)));
evalcond[1]=((((-1.0)*new_r02*x757))+new_r20);
evalcond[2]=((((-1.0)*x753))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x757)));
evalcond[4]=(((cj5*x753))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*cj5*x757))+(((-1.0)*new_r00)));
evalcond[6]=(x753+((new_r02*new_r21))+((new_r21*x758)));
evalcond[7]=(((new_r20*x758))+((new_r02*new_r20))+(((-1.0)*x757)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x761=IKPowWithIntegerCheck(sj5,-1);
if(!x761.valid){
continue;
}
IkReal x760=x761.value;
CheckValue<IkReal> x762=IKPowWithIntegerCheck(cj4,-1);
if(!x762.valid){
continue;
}
CheckValue<IkReal> x763=IKPowWithIntegerCheck(cj5,-1);
if(!x763.valid){
continue;
}
if( IKabs((x760*(x762.value)*(x763.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x760)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x760*(x762.value)*(x763.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x760))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x760*(x762.value)*(x763.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x760));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x764=IKsin(j6);
IkReal x765=IKcos(j6);
IkReal x766=((1.0)*sj5);
IkReal x767=((1.0)*sj4);
IkReal x768=(cj5*sj4);
IkReal x769=(cj4*new_r01);
IkReal x770=(cj4*new_r00);
IkReal x771=((1.0)*x765);
IkReal x772=(cj5*x764);
IkReal x773=((1.0)*x764);
evalcond[0]=(new_r20+((sj5*x765)));
evalcond[1]=((((-1.0)*x764*x766))+new_r21);
evalcond[2]=(((new_r11*sj4))+x772+x769);
evalcond[3]=((((-1.0)*new_r00*x767))+((cj4*new_r10))+(((-1.0)*x773)));
evalcond[4]=(((cj4*new_r11))+(((-1.0)*x771))+(((-1.0)*new_r01*x767)));
evalcond[5]=(((sj4*x765))+new_r01+((cj4*x772)));
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x771))+x770);
evalcond[7]=(((sj4*x764))+new_r00+(((-1.0)*cj4*cj5*x771)));
evalcond[8]=((((-1.0)*cj4*x771))+new_r11+((x764*x768)));
evalcond[9]=((((-1.0)*cj4*x773))+new_r10+(((-1.0)*cj5*x765*x767)));
evalcond[10]=(((new_r11*x768))+((cj5*x769))+x764+(((-1.0)*new_r21*x766)));
evalcond[11]=((((-1.0)*new_r20*x766))+((new_r10*x768))+(((-1.0)*x771))+((cj5*x770)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x775=IKPowWithIntegerCheck(sj5,-1);
if(!x775.valid){
continue;
}
IkReal x774=x775.value;
CheckValue<IkReal> x776=IKPowWithIntegerCheck(sj4,-1);
if(!x776.valid){
continue;
}
if( IKabs((x774*(x776.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x774)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x774*(x776.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x774))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x774*(x776.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x774));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x777=IKsin(j6);
IkReal x778=IKcos(j6);
IkReal x779=((1.0)*sj5);
IkReal x780=((1.0)*sj4);
IkReal x781=(cj5*sj4);
IkReal x782=(cj4*new_r01);
IkReal x783=(cj4*new_r00);
IkReal x784=((1.0)*x778);
IkReal x785=(cj5*x777);
IkReal x786=((1.0)*x777);
evalcond[0]=(((sj5*x778))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x777*x779)));
evalcond[2]=(((new_r11*sj4))+x782+x785);
evalcond[3]=((((-1.0)*x786))+((cj4*new_r10))+(((-1.0)*new_r00*x780)));
evalcond[4]=((((-1.0)*new_r01*x780))+(((-1.0)*x784))+((cj4*new_r11)));
evalcond[5]=(((sj4*x778))+((cj4*x785))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x784))+x783);
evalcond[7]=(((sj4*x777))+(((-1.0)*cj4*cj5*x784))+new_r00);
evalcond[8]=((((-1.0)*cj4*x784))+new_r11+((x777*x781)));
evalcond[9]=((((-1.0)*cj5*x778*x780))+(((-1.0)*cj4*x786))+new_r10);
evalcond[10]=(((new_r11*x781))+((cj5*x782))+(((-1.0)*new_r21*x779))+x777);
evalcond[11]=(((new_r10*x781))+(((-1.0)*x784))+(((-1.0)*new_r20*x779))+((cj5*x783)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x787=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x787.valid){
continue;
}
CheckValue<IkReal> x788 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x788.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x787.value)))+(x788.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x789=IKsin(j6);
IkReal x790=IKcos(j6);
IkReal x791=((1.0)*sj5);
IkReal x792=((1.0)*sj4);
IkReal x793=(cj5*sj4);
IkReal x794=(cj4*new_r01);
IkReal x795=(cj4*new_r00);
IkReal x796=((1.0)*x790);
IkReal x797=(cj5*x789);
IkReal x798=((1.0)*x789);
evalcond[0]=(((sj5*x790))+new_r20);
evalcond[1]=((((-1.0)*x789*x791))+new_r21);
evalcond[2]=(((new_r11*sj4))+x794+x797);
evalcond[3]=((((-1.0)*x798))+((cj4*new_r10))+(((-1.0)*new_r00*x792)));
evalcond[4]=((((-1.0)*new_r01*x792))+(((-1.0)*x796))+((cj4*new_r11)));
evalcond[5]=(((cj4*x797))+((sj4*x790))+new_r01);
evalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x796))+x795);
evalcond[7]=((((-1.0)*cj4*cj5*x796))+((sj4*x789))+new_r00);
evalcond[8]=(new_r11+(((-1.0)*cj4*x796))+((x789*x793)));
evalcond[9]=((((-1.0)*cj5*x790*x792))+new_r10+(((-1.0)*cj4*x798)));
evalcond[10]=((((-1.0)*new_r21*x791))+((new_r11*x793))+((cj5*x794))+x789);
evalcond[11]=((((-1.0)*x796))+((new_r10*x793))+((cj5*x795))+(((-1.0)*new_r20*x791)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "9474bf62a2af5d9b0004aed8edd6a12e"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
